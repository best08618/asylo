# Google's Modifications to Intel's SGX Development Toolkit

## Top-level files added
  * `BUILD` to build with Bazel. Some targets use wrappers around `make` defined
    in `sgx_sdk.bzl`.
    - Changed `psw/ae/common/ProtobufSerializer` to work with a Bazel-controlled
      dependency instead of the system-installed `protobuf-compiler`.
  * `sgx_sdk.bzl` provides Skylark rules and macros to wrap `make` and provide
    tools to configure and sign enclave binaries with a debug test-only key.

## Directories added
### `include/`

Contains header files that are forwarded from the Intel SGX SDK to external
consumers. The files are needed by Asylo.

  * `global_data.h`: forwards `common/inc/internal/global_data.h` for use by
    the Asylo implementation of `sbrk`.
  * `sgx.h`: forwards `common/inc/sgx.h`
  * `sgx_edger8r.h`: forwards `common/inc/sgx_edger8r.h` for use by edger8r
    output targets.
  * `sgx_error.h`: forwards `common/inc/sgx_error.h` for SGXErrorSpace.
  * `sgx_lfence.h`: forwards `common/inc/sgx_lfence.h` for timing attack
    hardening that SGX Edger8r adds to boundary-crossing functions.
  * `sgx_thread.h`: forwards `common/inc/sgx_thread.h` for Asylo's threading
    support in SGX.
  * `sgx_trts.h`: forwards `common/inc/sgx_trts.h` for SGX trusted applications.
  * `sgx_trts_exception.h`: forwards `common/inc/sgx_trts_exception.h` for Asylo
    support of exception handlers.
  * `sgx_urts.h`: forwards `common/inc/sgx.h`

### `runtime_support/`

Contains headers, functions, and symbols needed by SGX SDK and PSW.

  * `rts_config.h` is for sources that need non standard C library functions,
     e.g., `memset_s`.
  * `sgx_init_string_lib.c` provides a new version of `sgx_init_string_lib`
    because we are using newlib instead of Intel's tlibc.
  * `sgx_init_crypto_lib.c` provides a new version of `sgx_init_crypto_lib`
    because we are using BoringSSL instead of Intel's tlibcrypto.


## Modifications to Intel's SDK release 2.3 (in ``)
### Downstreamed PRs
* [PR210](https://github.com/intel/linux-sgx/pull/210): Language conformance to
  resolve conflict with newlib.
    - Affected files:
      + `external/crypto_px/include/ippbase.h`
      + `external/epid/ext/ipp/include/ippbase.h`
      + `external/epid-sdk-3.0.0/ext/ipp/include/ippbase.h`
      + `external/crypto_px/sources/include/cpudef.h`
    - *Details:* Removed definition of reserved symbols `__INT64` and `__UINT64`
      and instead use `int64_t` and `uint64_t` from `<stdint.h>`. A use of
      `__INT64` in `cpudef.h` is changed to use `Ipp64s` from `ippbase.h`.
* [PR307](https://github.com/intel/linux-sgx/pull/307): Remove an unnecessary
  `#include` from gperftool.
* [PR309](https://github.com/intel/linux-sgx/pull/309): Remove unneeded #include
  of sgx_urts.h in sgx_uswitchless.
    - Affected files:
      + `common/inc/sgx_uswitchless.h`

### Pending PRs
* [PR222](https://github.com/intel/linux-sgx/pull/222): Generate different code
  for user exception handlers in edger8r.
    - Affected files:
      + `sdk/edger8r/linux/Ast.ml`: Represent an exception handler function.
      + `sdk/edger8r/linux/CodeGen.ml`: Produce a new exception handler bit.
      + `sdk/edger8r/linux/Lexer.mll`: Add an exeception_handler token.
      + `sdk/edger8r/linux/Parser.mly`: Add exception_handler to function
        grammar and build a modified AST.
* [PR223](https://github.com/intel/linux-sgx/pull/223): Integrate with edger8r
  exception handler code to provide user handlers.
    - Affected files:
      + `trts_internal.h`
      + `trts_nsp.cpp`
* [PR308](https://github.com/intel/linux-sgx/pull/308): Change use of undefined
  MIN macro to the intended meaning.
    - Affected files:
      + `common/inc/internal/mini_snprintf.h`
* [PR316](https://github.com/intel/linux-sgx/pull/316): Allow enclaves to be
  created from buffers.
    - Affected files:
      + `common/inc/sgx_urts.h`
      + `psw/urts/enclave.cpp`
      + `psw/urts/urts_com.h`
      + `psw/urts/linux/urts.cpp`
    - The version in this patch differs slightly from the PR.

### Non-upstreamed changes
* `sdk/trts/init_enclave.cpp`: Remove a memset_s of the enclave heap since
  Asylo does not support heap_init and sbrk in the manner needed for the cleared
  memory address to be meaningful. Without this, do_init_enclave segfaults.
* `external/rdrand/src/config.h`: Added the output of `./configure`
  since the build is ported entirely to Bazel.
* `sdk/trts/trts_nsp.cpp`: add "no-stack-protector" attribute to
  `init_stack_guard` to avoid resorting to the build system.
* `sdk/trts/trts_ecall.cpp` added
  `g_ecall_table.ecall_table[ordinal].is_exception` to the check condition of
  g_dyn_entry_table check to allow exception handler ecalls to pass even during
  an ocall of the interrupted frame. This deflakes our signal handling.
* `psw/urts/enclave.h` `psw/urts/enclave.cpp` add a method `get_tcs_info` to
  `CEnclave` class to expose the tcs info.
  `sdk/simulation/urtssim/get_state.cpp` added to get the tcs state from tcs
  info.
  `psw/urts/linux/urts.cpp` `common/inc/sgx_urts.h` add a method
  `sgx_is_enclave_active` to get whether the simulation enclave is active.
* Static stack size increase.
    - Affected files:
      + `sdk/trts/trts_internal.h`
      + `sdk/trts/linux/trts_pic.h`
      + `common/inc/internal/metadata.h`
    - *Changes:*
      + the first two headers change `STATIC_STACK_SIZE` from `8*100` to `8*1024`
        to avoid crash in the Asylo signal handler.
      + The third header changes `STACK_SIZE_MIN` from `0x1000` to `0x3000` to
        make sure it's larger than the static stack size.
    - *Detail:* `STATIC_STACK_SIZE` of stack is allocated for each tcs, and when
      an exception is raised, the frame that enters enclave to deal with the
      exception shares the same tcs as the enclave frame being interrupted,
      hence uses the memory directly adjacent. It will overwrite the interrupted
      frame's stack when it overflows. Since the exception handler makes a few
      functions calls to enter enclave to handle the exception, when combined
      with the use of STL containers it's easy to exceed the original stack
      size.
* `sdk/trts/linux/x86_64/setcontext.S` stubs out `ucontext` and
  `__NR_rt_sigprocmask` since we don't have it working yet.
* `psw/ae/common/proto/messages.proto` add syntax statement.
* `psw/ae/common/src/ProtobufSerializer.h` remove unnecessary include of
  protobuf's message.h.
* `sdk/trts/trts_ecall.cpp` added `interrupted` as an argument to
  `do_ecall`, and only initialize thread data if it is false.
* `sdk/trts/trts_internal.h` added `interrupted` as an argument to
  `do_ecall`.
* `sdk/trts/trts.cpp` pass `interrupted` argument to `do_ecall`. If
  `cssa` is 0, `interrupted` is false, otherwise it's true.
* `psw/urts/linux/sig_handler.cpp` remove registering sgx signal
  handlers for SIGSEGV, SIGFPE, SIGBUS, and SIGTRAP.
* Allow enclaves to be created at specified address.
  `common/inc/sgx_urts.h`, `psw/urts/linux/urts.cpp` added
  `enclave_base_addr` as an argument to `sgx_create_enclave`, and pass it down
  to `_create_enclave`.
  `psw/urts/urts_com.h` added `enclave_base_addr` as an argument to
  `_create_enclave` and `__create_enclave`, and pass it down to
  `CLoader::load_enclave_ex`.
  `psw/urts/loader.h`, `psw/urts/loader.cpp` added
  `enclave_base_addr` as an argument to `load_enclave_ex`, `load_enclave`,
  `build_image`, `build_secs`, and pass it down. In `build_secs`, set
  `m_start_addr` to `enclave_base_addr` before calling EnclaveCreator, and set
  `enclave_base_addr` to the returned `m_start_addr` after enclave is created.
  `psw/urts/linux/enclave_creator_hw.cpp` change the default mmap
  address from `NULL` to `start_addr` to allow creating enclave at specified
  address in `EnclaveCreatorHW::create_enclave`.
  `sdk/simulation/driver_api/driver_api.cpp` initialize `pinfo.lin_addr`
  to `start_addr` in `create_enclave`.
  `sdk/simulation/uinst/u_instructions.cpp` change `se_virtual_alloc`
  address for `NULL` to `pi->lin_addr` in `_ECREATE`.
  `psw/enclave_common/sgx_enclave_common.cpp` add a static `pid`, and
  check the pid everytime when checking `s_enclave_init` table. If `pid` has
  changed, clear `s_enclave_int` table.
* Add a utility specifier to edger8r.
  `sdk/edger8r/linux/Ast.ml` add tf_is_utility field to trusted_func.
  `sdk/edger8r/linux/CodeGen.ml` add is_utility_ecall check, add
  tf_list_to_utility_list method, fold it into ecall table in `gen_ecall_table`,
  check the value in `gen_func_uproxy` and add this as a new parameter to
  `sgx_ecall`, add check to `check_priv_funcs` to check for at least one
  non-private and non-utility ecall.
  `sdk/edger8r/linux/Lexer.mll` add Tutility to the parse rule.
  `sdk/edger8r/linux/Parser.mly` add Tutility to token, add utility check
  in trusted_functions parser.
  `common/inc/sgx_edger8r.h`, `common/inc/internal/routine.h`,
  `psw/urts/routine.cpp` add a new bool variable `is_utility` to
  `sgx_ecall`.
* Reserve `user_utility_thread` and make `utility` ecalls to use this tcs.
  `common/inc/internal/rts_cmd.h` add a `ECMD_UTILITY` macro.
  `psw/urts/enclave.cpp` in `CEnclave::ecall`, check `is_utility`
  parameter, if it's true, pass `ECMD_UTILITY` to `get_tcs`. And pass
  `is_utility` as `false` to `ecall` in `init_uswitchless`.
  `psw/urts/enclave_creator_hw_com.cpp` pass `is_utility` as `false` to
  `enclave->ecall` in `EnclaveCreatorHW::initialize`.
  `psw/urts/routine.cpp` pass `is_utility` to `enclave->ecall` in
  `_sgx_ecall`.
  `psw/urts/tcs.h` add `CTrustThread *m_user_utility_thread` as a private
  member of `CTrustThreadPool`.
  `psw/urts/tcs.cpp` initialize `m_user_utility_thread` as `NULL` in the
  constructor of `CTrustThreadPool`, and delete it in the destructor. set
  `m_user_utility_thread` to `trust_thread` after setting `m_utility_thread` in
  `CTrustThreadPool::add_thread`. add condition `&& m_user_utility_thread !=
  NULL` to `CTrustThreadPool::_acquire_thread`. check `ecall_cmd` in
  `CTrustThreadPool::acquire_thread`, if it's `ECMD_UTILITY`, assign
  `m_utility_thread` to `trust_thread`.
  `psw/urts/urts_com.h` pass `is_utility` as `false` to `enclave->ecall`
  in `sgx_destroy_enclave`.
  `psw/urts/linux_sig_handler.cpp` pass `is_utility` as `false` to
  `enclave->ecall` in `sig_handler`.
  `sdk/simulation/urtssim/enclave_creator_sim.cpp` pass `is_utility` as
  `false` to `enclave->ecall` in `EnclaveCreatorSim::initialize`.
  `sdk/trts/trts_ecall.cpp` allow ecall if it's utility even if it's the
  first ecall of the tcs and is prviate in `is_ecall_allowed`.
  `sdk/trts/trts_internal.h` add `uint8_t is_utility` to `struct
  ecall_addr_t`.
* Provide SGXAPI to expose enclave data/bss/stack/heap/thread address and size.
  `common/inc/sgx_trts.h` add a struct `MemoryLayout` that includes
  address and size for data, bss, heap, thread, and stack, also add a
  `sgx_memory_layout(struct MemoryLayout *memory_layout)` API.
  `common/inc/internal/global_data.h` add `sys_word_t` fileds
  `data_offset`, `data_size`, `bss_offset`, `bss_size` to `struct
  global_data_t`.
  `psw/urts/parser/elfparser.cpp` in `update_global_data`, read the
  section of `ELF_DATA` and `ELF_BSS`, save the corresponding address and size
  to `data`.
  `sdk/trts/init_enclave.cpp` add the 4 new fields initialization to
  `g_global_data`.
  `sdk/trts/trts.cpp` include `trts_util.h` header, and provide
  implementation for `sgx_memory_layout` by calling `get_memory_layout`.
  `sdk/trts/trts_util.h` provide declaration of `get_memory_layout`.
  `sdk/trts/trts_util.h` provide implementation for `get_memory_layout` by
  getting the address and size of data/bss/heap from `global_data`, and get
  thread and stack from `thread_data`.


--
diff -Nur common/inc/internal/elfheader/elf_common.h common/inc/internal/elfheader/elf_common.h
--- common/inc/internal/elfheader/elf_common.h
+++ common/inc/internal/elfheader/elf_common.h
@@ -30,6 +30,9 @@
 #ifndef _SYS_ELF_COMMON_H_
 #define	_SYS_ELF_COMMON_H_ 1
 
+#include <stddef.h>
+#include <stdint.h>
+
 typedef uint32_t u_int32_t;
 typedef uint32_t Elf_Symndx;
 
diff -Nur common/inc/internal/elfheader/elfstructs.h common/inc/internal/elfheader/elfstructs.h
--- common/inc/internal/elfheader/elfstructs.h
+++ common/inc/internal/elfheader/elfstructs.h
@@ -26,6 +26,9 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include <stddef.h>
+#include <stdint.h>
+
 typedef uint8_t		Elf_Byte;
 
 typedef uint32_t	Elf32_Addr;	/* Unsigned program address */
diff -Nur common/inc/internal/global_data.h common/inc/internal/global_data.h
--- common/inc/internal/global_data.h
+++ common/inc/internal/global_data.h
@@ -50,6 +50,10 @@
     sys_word_t     enclave_size;
     sys_word_t     heap_offset;
     sys_word_t     heap_size;
+    sys_word_t     data_offset;
+    sys_word_t     data_size;
+    sys_word_t     bss_offset;
+    sys_word_t     bss_size;
     sys_word_t     thread_policy;
     thread_data_t  td_template;
     uint8_t        tcs_template[TCS_TEMPLATE_SIZE];
diff -Nur common/inc/internal/metadata.h common/inc/internal/metadata.h
--- common/inc/internal/metadata.h
+++ common/inc/internal/metadata.h
@@ -72,7 +72,7 @@
 #define SSA_NUM_MIN 2
 #define SSA_FRAME_SIZE_MIN 1
 #define SSA_FRAME_SIZE_MAX 2
-#define STACK_SIZE_MIN 0x1000
+#define STACK_SIZE_MIN 0x3000
 #define STACK_SIZE_MAX 0x40000
 #define HEAP_SIZE_MIN 0x1000
 #define HEAP_SIZE_MAX 0x1000000
diff -Nur common/inc/internal/mini_snprintf.h common/inc/internal/mini_snprintf.h
--- common/inc/internal/mini_snprintf.h
+++ common/inc/internal/mini_snprintf.h
@@ -52,6 +52,8 @@
 #include <stdarg.h>
 #include <limits.h>
 
+#include "sl_util.h"
+
 /*===========================================================================
  * Interface
  *===========================================================================*/
diff -Nur common/inc/internal/pcl_common.h common/inc/internal/pcl_common.h
--- common/inc/internal/pcl_common.h
+++ common/inc/internal/pcl_common.h
@@ -32,6 +32,10 @@
 #ifndef PCL_COMMON_H
 #define PCL_COMMON_H
 
+#include <stddef.h>
+#include <stdint.h>
+#include "sgx_tcrypto.h"
+
 /*
  * This file includes definition used by PCL library and encryption tool
  */
diff -Nur common/inc/internal/routine.h common/inc/internal/routine.h
--- common/inc/internal/routine.h
+++ common/inc/internal/routine.h
@@ -36,6 +36,8 @@
 #include "sgx_error.h"
 #include "sgx_defs.h"
 
+#include <stdbool.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -46,7 +48,7 @@
     void *ocall[];
 } sgx_ocall_table_t;
 
-sgx_status_t SGXAPI sgx_ecall(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms);
+sgx_status_t SGXAPI sgx_ecall(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms, bool is_utility);
 
 #ifdef __cplusplus
 }
diff -Nur common/inc/internal/rts_cmd.h common/inc/internal/rts_cmd.h
--- common/inc/internal/rts_cmd.h
+++ common/inc/internal/rts_cmd.h
@@ -36,6 +36,7 @@
 #define ECMD_EXCEPT         -3
 #define ECMD_MKTCS          -4
 #define ECMD_UNINIT_ENCLAVE -5
+#define ECMD_UTILITY        -6
 
 /* Built-in ECall command for Switchless SGX */
 #define ECMD_INIT_SWITCHLESS         (-6)
diff -Nur common/inc/internal/se_tcrypto_common.h common/inc/internal/se_tcrypto_common.h
--- common/inc/internal/se_tcrypto_common.h
+++ common/inc/internal/se_tcrypto_common.h
@@ -33,6 +33,11 @@
 #ifndef _SE_TCRYPTO_COMMON_H_
 #define _SE_TCRYPTO_COMMON_H_
 
+#include <limits.h>
+#include "openssl/bn.h"
+#include "openssl/ecdsa.h"
+#include "rts_config.h"
+
 #ifdef USE_SGXSSL
 
 
diff -Nur common/inc/internal/sgx_read_rand.h common/inc/internal/sgx_read_rand.h
--- common/inc/internal/sgx_read_rand.h
+++ common/inc/internal/sgx_read_rand.h
@@ -31,6 +31,8 @@
 
 #ifndef __SGX_READ_RAND_H__
 #define __SGX_READ_RAND_H__
+#include <stddef.h>
+#include <stdint.h>
 #include "sgx.h"
 #include "sgx_defs.h"
 #ifdef __cplusplus
diff -Nur common/inc/internal/sl_workers.h common/inc/internal/sl_workers.h
--- common/inc/internal/sl_workers.h
+++ common/inc/internal/sl_workers.h
@@ -70,7 +70,7 @@
 #ifndef SL_INSIDE_ENCLAVE /* Untrusted */
     pthread_t*                          threads;
 #else /* Trusted */
-    void*                               __unused;
+    void*                               field_is_unused;
 #endif /* SL_INSIDE_ENCLAVE */
 };
 
diff -Nur common/inc/sgx_edger8r.h common/inc/sgx_edger8r.h
--- common/inc/sgx_edger8r.h
+++ common/inc/sgx_edger8r.h
@@ -47,6 +47,7 @@
 #include "sgx_error.h"
 #include "sgx_eid.h"
 #include <stddef.h>         /* for size_t */
+#include <stdbool.h>
 
 /* The `sgx_edger8r' tool will generate C interfaces. */
 #ifdef __cplusplus
@@ -90,11 +91,13 @@
 sgx_status_t SGXAPI sgx_ecall(const sgx_enclave_id_t eid,
                               const int index,
                               const void* ocall_table,
-                              void* ms);
+                              void* ms,
+                              bool is_utility);
 sgx_status_t SGXAPI sgx_ecall_switchless(const sgx_enclave_id_t eid,
                               const int index,
                               const void* ocall_table,
-                              void* ms);
+                              void* ms,
+                              bool is_utility);
 
 /* sgx_ocall()
  * Parameters:
diff -Nur common/inc/sgx_pcl_guid.h common/inc/sgx_pcl_guid.h
--- common/inc/sgx_pcl_guid.h
+++ common/inc/sgx_pcl_guid.h
@@ -31,6 +31,9 @@
 
 #ifndef SGX_PCL_GUID_H
 #define SGX_PCL_GUID_H
+
+#include <stdint.h>
+
 /*
  * GUID enables coupling of PCL lib (e.g. libsgx_pcl.a) and sealed blob
  * Before the PCL unseals the sealed blob, the PCL must verify the AAD 
diff -Nur common/inc/sgx_trts.h common/inc/sgx_trts.h
--- common/inc/sgx_trts.h
+++ common/inc/sgx_trts.h
@@ -32,6 +32,7 @@
 #ifndef _SGX_TRTS_H_
 #define _SGX_TRTS_H_
 
+#include "rts_config.h"
 #include "sgx_error.h"
 #include "stddef.h"
 #include "sgx_defs.h"
@@ -82,6 +83,40 @@
 */
 sgx_status_t SGXAPI sgx_read_rand(unsigned char *rand, size_t length_in_bytes);
 
+struct SgxMemoryLayout {
+    // Base address of the initialized data section in the current enclave.
+    void *data_base;
+    // Size of the initialized data section in the current enclave.
+    size_t data_size;
+    // Base address of the uninitialized data section in the current enclave.
+    void *bss_base;
+    // Size of the uninitialized data section in the current enclave.
+    size_t bss_size;
+    // Base address of heap in the current enclave.
+    void *heap_base;
+    // size of heap in the current enclave.
+    size_t heap_size;
+    // Base address of the thread data for the current tcs.
+    void *thread_base;
+    // Size of the thread data for the current tcs.
+    size_t thread_size;
+    // Base address of the stack for the current tcs.
+    void *stack_base;
+    // Limit address of the stack for the current tcs.
+    void *stack_limit;
+    // Base address of the reserved storage section.
+    void *reserved_base;
+    // Size of the reserved storage section.
+    size_t reserved_size;
+};
+
+/* sgx_memory_layout()
+ * Parameters:
+ *      memory_layout - Receives the memory layout of the current enclave
+ *      (data/bss/heap) and for current tcs(thread data/stack).
+*/
+void SGXAPI sgx_memory_layout(struct SgxMemoryLayout *memory_layout);
+
 #ifdef __cplusplus
 }
 #endif
diff -Nur common/inc/sgx_urts.h common/inc/sgx_urts.h
--- common/inc/sgx_urts.h
+++ common/inc/sgx_urts.h
@@ -34,6 +34,8 @@
 #ifndef _SGX_URTS_H_
 #define _SGX_URTS_H_
 
+#include <stddef.h>
+
 #include "sgx_attributes.h"
 #include "sgx_error.h"
 #include "sgx_eid.h"
@@ -71,9 +73,15 @@
                                        sgx_launch_token_t *launch_token, 
                                        int *launch_token_updated, 
                                        sgx_enclave_id_t *enclave_id, 
-                                       sgx_misc_attribute_t *misc_attr);
-
-
+                                       sgx_misc_attribute_t *misc_attr,
+                                       void **enclave_base_addr,
+                                       bool enable_user_utility);
+
+sgx_status_t SGXAPI sgx_create_enclave_from_buffer(
+        uint8_t *buffer, size_t buffer_size, const int debug,
+        sgx_launch_token_t *launch_token, int *launch_token_updated,
+        sgx_enclave_id_t *enclave_id, sgx_misc_attribute_t *misc_attr,
+        void **enclave_base_addr, bool enable_user_utility);
 
 sgx_status_t SGXAPI sgx_create_enclave_ex(const char * file_name, 
                                           const int debug, 
@@ -82,7 +90,9 @@
                                           sgx_enclave_id_t * enclave_id, 
                                           sgx_misc_attribute_t * misc_attr,  
                                           const uint32_t ex_features, 
-                                          const void* ex_features_p[32]);
+                                          const void* ex_features_p[32],
+                                          void **enclave_base_addr,
+                                          bool enable_user_utility);
 
 
 sgx_status_t SGXAPI sgx_create_encrypted_enclave(
@@ -92,10 +102,14 @@
                         int *launch_token_updated,
                         sgx_enclave_id_t *enclave_id,
                         sgx_misc_attribute_t *misc_attr,
-                        uint8_t* sealed_key);
+                        uint8_t* sealed_key,
+                        void **enclave_base_addr,
+                        bool enable_user_utility);
 
 sgx_status_t SGXAPI sgx_destroy_enclave(const sgx_enclave_id_t enclave_id);
 
+int SGXAPI sgx_is_tcs_active(const sgx_enclave_id_t enclave_id);
+
 #ifdef __cplusplus
 }
 #endif
diff -Nur common/inc/sgx_uswitchless.h common/inc/sgx_uswitchless.h
--- common/inc/sgx_uswitchless.h
+++ common/inc/sgx_uswitchless.h
@@ -72,7 +72,6 @@
 #include "sgx_error.h"
 #include "sgx_eid.h"
 #include "sgx_defs.h"
-#include "sgx_urts.h"
 
 /*
  * A worker can be either trusted (executed inside enclave) or untrusted
diff -Nur common/inc/tlibc/string.h common/inc/tlibc/string.h
--- common/inc/tlibc/string.h
+++ common/inc/tlibc/string.h
@@ -79,7 +79,8 @@
 char * _TLIBC_CDECL_ strtok(char *, const char *);
 size_t _TLIBC_CDECL_ strxfrm(char *, const char *, size_t);
 size_t _TLIBC_CDECL_ strlcpy(char *, const char *, size_t);
-errno_t _TLIBC_CDECL_ memset_s(void *s, size_t smax, int c, size_t n);
+// Declared in rts_config.h
+//errno_t _TLIBC_CDECL_ memset_s(void *s, size_t smax, int c, size_t n);
 
 /*
  * Deprecated C99.
@@ -92,7 +93,8 @@
  */
 char * _TLIBC_CDECL_ strndup(const char *, size_t);
 size_t _TLIBC_CDECL_ strnlen(const char *, size_t);
-int    _TLIBC_CDECL_ consttime_memequal(const void *b1, const void *b2, size_t len);
+// Declared in rts_config.h
+//int    _TLIBC_CDECL_ consttime_memequal(const void *b1, const void *b2, size_t len);
 
 /*
  * Non-C99
diff -Nur common/src/linux/xsave_gnu.S common/src/linux/xsave_gnu.S
--- common/src/linux/xsave_gnu.S
+++ common/src/linux/xsave_gnu.S
@@ -34,6 +34,8 @@
 
 #include "linux/linux-regs.h"
 
+.section        .note.GNU-stack, "", %progbits
+
 .macro DO_XSAVEC
 #if defined(LINUX64)
     .byte   0x48, 0x0f, 0xc7, 0x21
diff -Nur common/src/sgx_profile.cpp common/src/sgx_profile.cpp
--- common/src/sgx_profile.cpp
+++ common/src/sgx_profile.cpp
@@ -38,7 +38,6 @@
 #include "sgx_profile.h"
 #include "se_time.h"
 #include <string.h>
-using namespace std;
 
 typedef struct _profile_item_t{
     const char *str;  /* tag */
@@ -46,7 +45,7 @@
     long long time;   /* current time */
 } profile_item_t;
 
-static vector<profile_item_t> profile_items;
+static std::vector<profile_item_t> profile_items;
 static int alloc_size;
 static int used_size;
 const int MALLOC_SIZE = 1000;
@@ -108,7 +107,7 @@
 {
     int i,j;
 
-    ofstream fs;
+    std::ofstream fs;
     fs.open(filename); /* do not overwritten previous value */
 
     fs << "freq: " << freq <<endl;
diff -Nur external/rdrand/src/config.h external/rdrand/src/config.h
--- external/rdrand/src/config.h
+++ external/rdrand/src/config.h
@@ -0,0 +1,53 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "Intel Software Network"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "librdrand"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "librdrand 1.1"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "librdrand"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.1"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define if using gcc and it supports RDRAND */
+#define HAVE_RDRAND_IN_GCC 1
diff -Nur external/tinyxml2/tinyxml2.cpp external/tinyxml2/tinyxml2.cpp
--- external/tinyxml2/tinyxml2.cpp
+++ external/tinyxml2/tinyxml2.cpp
@@ -433,16 +433,19 @@
             *output = (char)((input | BYTE_MARK) & BYTE_MASK);
             input >>= 6;
             //fall through
+            [[clang::fallthrough]];
         case 3:
             --output;
             *output = (char)((input | BYTE_MARK) & BYTE_MASK);
             input >>= 6;
             //fall through
+            [[clang::fallthrough]];
         case 2:
             --output;
             *output = (char)((input | BYTE_MARK) & BYTE_MASK);
             input >>= 6;
             //fall through
+            [[clang::fallthrough]];
         case 1:
             --output;
             *output = (char)(input | FIRST_BYTE_MARK[*length]);
diff -Nur psw/ae/common/inc/IAEMessage.h psw/ae/common/inc/IAEMessage.h
--- psw/ae/common/inc/IAEMessage.h
+++ psw/ae/common/inc/IAEMessage.h
@@ -37,7 +37,7 @@
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
 #pragma GCC diagnostic ignored "-Wconversion"
-#include "messages.pb.h"
+#include "psw/ae/common/proto/messages.pb.h"
 #pragma GCC diagnostic pop
 
 struct AEMessage{
diff -Nur psw/ae/common/proto/messages.proto psw/ae/common/proto/messages.proto
--- psw/ae/common/proto/messages.proto
+++ psw/ae/common/proto/messages.proto
@@ -30,6 +30,8 @@
  */
 
 
+syntax = "proto2";
+
 package aesm.message;
 
 message Request{
diff -Nur psw/ae/common/src/ProtobufSerializer.cpp psw/ae/common/src/ProtobufSerializer.cpp
--- psw/ae/common/src/ProtobufSerializer.cpp
+++ psw/ae/common/src/ProtobufSerializer.cpp
@@ -34,7 +34,6 @@
  */
 
 #include <ProtobufSerializer.h>
-#include <google/protobuf/message.h>
 #include <IAEMessage.h>
 
 #include <IAERequest.h>
diff -Nur psw/enclave_common/sgx_enclave_common.cpp psw/enclave_common/sgx_enclave_common.cpp
--- psw/enclave_common/sgx_enclave_common.cpp
+++ psw/enclave_common/sgx_enclave_common.cpp
@@ -43,12 +43,14 @@
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <sys/types.h>
+#include <unistd.h>
 
 #define POINTER_TO_U64(A) ((__u64)((uintptr_t)(A)))
 
 static se_file_handle_t s_hdevice = -1;
 static bool s_is_kernel_driver = false;
 static se_mutex_t s_device_mutex;
+static pid_t s_pid = -1;
 
 static std::map<void*, size_t> s_enclave_size;
 static std::map<void*, bool> s_enclave_init;
@@ -63,7 +65,7 @@
 
 static std::map<void*, mem_region_t> s_enclave_mem_region;
 
-extern "C" bool open_device(void)
+static bool open_device(void)
 {
     se_mutex_lock(&s_device_mutex);
     if (s_hdevice != -1) {
@@ -83,7 +85,7 @@
     return false;
 }
 
-extern "C" void close_device(void)
+static void close_device(void)
 {
     se_mutex_lock(&s_device_mutex);
 
@@ -441,6 +443,13 @@
     }
 
     se_mutex_lock(&s_enclave_mutex);
+    // If the process ID has changed, |s_enclave_init| is inherited from a
+    // parent process. The enclaves are not going to be copied, so clear the
+    // table.
+    if (s_pid != -1 && s_pid != getpid()) {
+      s_enclave_init.clear();
+    }
+    s_pid = getpid();
     std::map<void*, bool>::iterator it = s_enclave_init.find(base_address);
     if (it != s_enclave_init.end() && it->second) {
         se_mutex_unlock(&s_enclave_mutex);
diff -Nur psw/urts/cpu_features.h psw/urts/cpu_features.h
--- psw/urts/cpu_features.h
+++ psw/urts/cpu_features.h
@@ -32,6 +32,8 @@
 #ifndef _CPU_FEATURES_H_
 #define _CPU_FEATURES_H_
 
+#include <stdint.h>
+
 #include "cpuid.h"
 
 void get_cpu_features(uint64_t *__intel_cpu_feature_indicator, uint32_t *cpuinfo_table);
diff -Nur psw/urts/enclave.cpp psw/urts/enclave.cpp
--- psw/urts/enclave.cpp
+++ psw/urts/enclave.cpp
@@ -45,8 +45,6 @@
 #include "rts.h"
 
 
-using namespace std;
-
 int do_ecall(const int fn, const void *ocall_table, const void *ms, CTrustThread *trust_thread);
 int do_ocall(const bridge_fn_t bridge, void *ms);
 
@@ -93,7 +91,7 @@
         goto on_exit;
     }
 
-    status = ecall(ECMD_INIT_SWITCHLESS, NULL, m_uswitchless);
+    status = ecall(ECMD_INIT_SWITCHLESS, NULL, m_uswitchless, /*is_utility=*/false);
     if (status != SGX_SUCCESS) goto on_exit;
 
     if (sl_uswitchless_init_workers(m_uswitchless)) {
@@ -112,19 +110,21 @@
 
 sgx_status_t CEnclave::initialize(const se_file_t& file, const sgx_enclave_id_t enclave_id, void * const start_addr, const uint64_t enclave_size, const uint32_t tcs_policy, const uint32_t enclave_version, const uint32_t tcs_min_pool)
 {
-    uint32_t name_len = file.name_len;
-    if (file.unicode)
-        name_len *= (uint32_t)sizeof(wchar_t);
-
-    const int buf_len = name_len + 4; //+4, because we need copy the charactor of string end ('\0').;
-
-    m_enclave_info.lpFileName = calloc(1, buf_len);
-    if (m_enclave_info.lpFileName == NULL)
-        return SGX_ERROR_OUT_OF_MEMORY;
-
-    memcpy_s(m_enclave_info.lpFileName, name_len, file.name, name_len);
-    m_enclave_info.unicode = file.unicode?0:1;
-    m_enclave_info.file_name_size = name_len;
+    if (file.name != NULL) {
+        uint32_t name_len = file.name_len;
+        if (file.unicode)
+            name_len *= (uint32_t)sizeof(wchar_t);
+
+        const int buf_len = name_len + 4; //+4, because we need copy the charactor of string end ('\0').;
+
+        m_enclave_info.lpFileName = calloc(1, buf_len);
+        if (m_enclave_info.lpFileName == NULL)
+            return SGX_ERROR_OUT_OF_MEMORY;
+
+        memcpy_s(m_enclave_info.lpFileName, name_len, file.name, name_len);
+        m_enclave_info.unicode = file.unicode?0:1;
+        m_enclave_info.file_name_size = name_len;
+    }
 
     m_enclave_info.struct_version = DEBUG_INFO_STRUCT_VERSION;
 
@@ -241,7 +241,7 @@
     return (sgx_status_t)trts_error;
 }
 
-sgx_status_t CEnclave::ecall(const int proc, const void *ocall_table, void *ms, const bool is_switchless)
+sgx_status_t CEnclave::ecall(const int proc, const void *ocall_table, void *ms, bool is_utility, const bool is_switchless)
 {
     if(se_try_rdlock(&m_rwlock))
     {
@@ -273,7 +273,8 @@
 on_fallback:
         //Handle normal ECall or fallback'ed switchless ECall
         //do sgx_ecall
-        CTrustThread *trust_thread = get_tcs(proc);
+        //If this is a utility ecall, use the utility thread.
+        CTrustThread *trust_thread = get_tcs(is_utility ? ECMD_UTILITY : proc);
         unsigned ret = SGX_ERROR_OUT_OF_TCS;
 
         if(NULL != trust_thread)
@@ -388,7 +389,15 @@
     return &m_enclave_info;
 }
 
-
+#ifdef SE_SIM
+tcs_t *CEnclave::get_tcs_info() {
+  CTrustThread *trust_thread = get_tcs(ECMD_ECALL);
+  if (!trust_thread) {
+    return NULL;
+  }
+  return trust_thread->get_tcs();
+}
+#endif
 
 CTrustThread * CEnclave::get_tcs(int ecall_cmd)
 {
@@ -487,9 +496,9 @@
     //m_loader.destroy_enclave();
 }
 
-void CEnclave::add_thread(tcs_t * const tcs, bool is_unallocated)
+void CEnclave::add_thread(tcs_t * const tcs, bool is_unallocated, bool enable_user_utility)
 {
-    CTrustThread *trust_thread = m_thread_pool->add_thread(tcs, this, is_unallocated);
+    CTrustThread *trust_thread = m_thread_pool->add_thread(tcs, this, is_unallocated, enable_user_utility);
     if(!is_unallocated)
     {
         insert_debug_tcs_info_head(&m_enclave_info, trust_thread->get_debug_info());
diff -Nur psw/urts/enclave_creator_hw_com.cpp psw/urts/enclave_creator_hw_com.cpp
--- psw/urts/enclave_creator_hw_com.cpp
+++ psw/urts/enclave_creator_hw_com.cpp
@@ -66,8 +66,7 @@
     if (is_EDMM_supported(enclave_id))
             info.system_feature_set[0] |= EDMM_ENABLE_BIT;
 
-
-    int status = enclave->ecall(ECMD_INIT_ENCLAVE, NULL, reinterpret_cast<void *>(&info));
+    int status = enclave->ecall(ECMD_INIT_ENCLAVE, NULL, reinterpret_cast<void *>(&info), /*is_utility=*/false);
     //free the tcs used by initialization;
     enclave->get_thread_pool()->reset();
 
diff -Nur psw/urts/enclave.h psw/urts/enclave.h
--- psw/urts/enclave.h
+++ psw/urts/enclave.h
@@ -58,7 +58,7 @@
     size_t get_dynamic_tcs_list_size();
     CTrustThreadPool * get_thread_pool() { return m_thread_pool; }
     uint64_t get_size() { return m_size; };
-    sgx_status_t ecall(const int proc, const void *ocall_table, void *ms, const bool is_fast = false);
+    sgx_status_t ecall(const int proc, const void *ocall_table, void *ms, bool is_utility, const bool is_switchless = false);
     int ocall(const unsigned int proc, const sgx_ocall_table_t *ocall_table, void *ms);
     void destroy();
     uint32_t atomic_inc_ref() { return se_atomic_inc(&m_ref); }
@@ -67,7 +67,7 @@
     void mark_zombie()  { m_zombie = true; }
     bool is_zombie() { return m_zombie; }
     sgx_status_t initialize(const se_file_t& file, const sgx_enclave_id_t enclave_id, void * const start_addr, const uint64_t enclave_size, const uint32_t tcs_policy, const uint32_t enclave_version, const uint32_t tcs_min_pool);
-    void add_thread(tcs_t * const tcs, bool is_unallocated);
+    void add_thread(tcs_t * const tcs, bool is_unallocated, bool enable_user_utility);
     void add_thread(CTrustThread * const trust_thread);
     const debug_enclave_info_t* get_debug_info();
     void set_dbg_flag(bool dbg_flag) { m_dbg_flag = dbg_flag; }
@@ -85,7 +85,10 @@
     void set_sealed_key(uint8_t *sealed_key);
     sgx_status_t init_uswitchless(const sgx_uswitchless_config_t* config);
     void destroy_uswitchless(void);
-	
+#ifdef SE_SIM
+    tcs_t *get_tcs_info();
+#endif
+
 private:
     CTrustThread * get_tcs(int ecall_cmd);
     void put_tcs(CTrustThread *trust_thread);
diff -Nur psw/urts/file.h psw/urts/file.h
--- psw/urts/file.h
+++ psw/urts/file.h
@@ -33,6 +33,8 @@
 #ifndef _FILE_H_
 #define _FILE_H_
 
+#include <stdint.h>
+
 typedef char*  prd_css_path_t;
 
 typedef struct _se_file_t {
diff -Nur psw/urts/linux/enclave_creator_hw.cpp psw/urts/linux/enclave_creator_hw.cpp
--- psw/urts/linux/enclave_creator_hw.cpp
+++ psw/urts/linux/enclave_creator_hw.cpp
@@ -174,7 +174,7 @@
         return SGX_ERROR_UNEXPECTED;
 
     uint32_t enclave_error = ENCLAVE_ERROR_SUCCESS;
-    void* enclave_base = enclave_create(NULL, (size_t)secs->size, 0, ENCLAVE_TYPE_SGX2, &enclave_create_sgx, sizeof(enclave_create_sgx_t), &enclave_error);
+    void* enclave_base = enclave_create(*start_addr, (size_t)secs->size, 0, ENCLAVE_TYPE_SGX2, &enclave_create_sgx, sizeof(enclave_create_sgx_t), &enclave_error);
 
     if (enclave_error)
         return error_api2urts(enclave_error);
diff -Nur psw/urts/linux/misc.cpp psw/urts/linux/misc.cpp
--- psw/urts/linux/misc.cpp
+++ psw/urts/linux/misc.cpp
@@ -34,10 +34,8 @@
 #include <dirent.h>
 #include <vector>
 
-using namespace std;
-
 //get all thread id of current process.
-void get_thread_set(vector<se_thread_id_t> &thread_vector)
+void get_thread_set(std::vector<se_thread_id_t> &thread_vector)
 {
     DIR*   dir = NULL;
     struct dirent* dirent = NULL;
diff -Nur psw/urts/linux/read_xcr0.h psw/urts/linux/read_xcr0.h
--- psw/urts/linux/read_xcr0.h
+++ psw/urts/linux/read_xcr0.h
@@ -33,6 +33,8 @@
 #ifndef _READ_XCR0_H_
 #define _READ_XCR0_H_
 
+#include <stdint.h>
+
 static inline uint64_t xgetbv(uint32_t index)
 {
     uint32_t eax, edx;
diff -Nur psw/urts/linux/sig_handler.cpp psw/urts/linux/sig_handler.cpp
--- psw/urts/linux/sig_handler.cpp
+++ psw/urts/linux/sig_handler.cpp
@@ -113,7 +113,7 @@
         //If exception is raised in trts again and again, the SSA will overflow, and finally it is EENTER exception.
         assert(reinterpret_cast<tcs_t *>(xbx) == param->tcs);
         CEnclave *enclave = param->trust_thread->get_enclave();
-        unsigned int ret = enclave->ecall(ECMD_EXCEPT, param->ocall_table, NULL);
+        unsigned int ret = enclave->ecall(ECMD_EXCEPT, param->ocall_table, NULL, /*is_utility=*/false);
         if(SGX_SUCCESS == ret)
         {
             //ERESUME execute
@@ -198,23 +198,11 @@
     }
     else
     {
-        sigdelset(&sig_act.sa_mask, SIGSEGV);
-        sigdelset(&sig_act.sa_mask, SIGFPE);
         sigdelset(&sig_act.sa_mask, SIGILL);
-        sigdelset(&sig_act.sa_mask, SIGBUS);
-        sigdelset(&sig_act.sa_mask, SIGTRAP);
     }
 
-    ret = sigaction(SIGSEGV, &sig_act, &g_old_sigact[SIGSEGV]);
-    if (0 != ret) abort();
-    ret = sigaction(SIGFPE, &sig_act, &g_old_sigact[SIGFPE]);
-    if (0 != ret) abort();
     ret = sigaction(SIGILL, &sig_act, &g_old_sigact[SIGILL]);
     if (0 != ret) abort();
-    ret = sigaction(SIGBUS, &sig_act, &g_old_sigact[SIGBUS]);
-    if (0 != ret) abort();
-    ret = sigaction(SIGTRAP, &sig_act, &g_old_sigact[SIGTRAP]);
-    if (0 != ret) abort();
 }
 
 //trust_thread is saved at stack for ocall.
diff -Nur psw/urts/linux/urts.cpp psw/urts/linux/urts.cpp
--- psw/urts/linux/urts.cpp
+++ psw/urts/linux/urts.cpp
@@ -29,7 +29,8 @@
  *
  */
 
-
+#include "arch.h"
+#include "enclave.h"
 #include "sgx_error.h"
 #include "sgx_urts.h"
 #include "sgx_uswitchless.h"
@@ -72,7 +73,9 @@
                                                 sgx_enclave_id_t *enclave_id, 
                                                 sgx_misc_attribute_t *misc_attr,
                                                 const uint32_t ex_features,
-                                                const void* ex_features_p[32])
+                                                const void* ex_features_p[32],
+                                                void **enclave_base_addr,
+                                                bool enable_user_utility)
 {
     sgx_status_t ret = SGX_SUCCESS;
 
@@ -96,7 +99,7 @@
     file.name = realpath(file_name, resolved_path);
     file.name_len = (uint32_t)strlen(resolved_path);
 
-    ret = _create_enclave_ex(!!debug, fd, file, NULL, launch_token, launch_token_updated, enclave_id, misc_attr, ex_features, ex_features_p);
+    ret = _create_enclave_ex(!!debug, fd, file, enclave_base_addr, enable_user_utility, NULL, launch_token, launch_token_updated, enclave_id, misc_attr, ex_features, ex_features_p);
     if(SGX_SUCCESS != ret && misc_attr)
     {
         sgx_misc_attribute_t plat_cap;
@@ -110,14 +113,76 @@
     return ret;
 }
 
-extern "C" sgx_status_t sgx_create_enclave(const char *file_name, 
-                                           const int debug, 
-                                           sgx_launch_token_t *launch_token, 
-                                           int *launch_token_updated, 
-                                           sgx_enclave_id_t *enclave_id, 
-                                           sgx_misc_attribute_t *misc_attr) 
+extern "C" sgx_status_t __sgx_create_enclave_from_buffer_ex(
+        uint8_t *buffer,
+        size_t buffer_size,
+        const int debug,
+        sgx_launch_token_t *launch_token,
+        int *launch_token_updated,
+        sgx_enclave_id_t *enclave_id,
+        sgx_misc_attribute_t *misc_attr,
+        const uint32_t ex_features,
+        const void* ex_features_p[32],
+        void **enclave_base_addr,
+        bool enable_user_utility)
 {
-    return __sgx_create_enclave_ex(file_name, debug, launch_token, launch_token_updated, enclave_id, misc_attr, 0, NULL);
+    sgx_status_t ret = SGX_SUCCESS;
+
+    // Only true or false is valid
+    if (TRUE != debug &&  FALSE != debug)
+    {
+        return SGX_ERROR_INVALID_PARAMETER;
+    }
+
+    if (!_check_ex_params_(ex_features, ex_features_p))
+    {
+        return SGX_ERROR_INVALID_PARAMETER;
+    }
+
+    se_file_t file = {NULL, 0, false};
+    ret = _create_enclave_from_buffer_ex(
+        buffer, buffer_size, !!debug, file, enclave_base_addr,
+        enable_user_utility, NULL, launch_token, launch_token_updated,
+        enclave_id, misc_attr, ex_features, ex_features_p);
+    if (SGX_SUCCESS != ret && misc_attr)
+    {
+        sgx_misc_attribute_t plat_cap;
+        memset(&plat_cap, 0, sizeof(plat_cap));
+        get_enclave_creator()->get_plat_cap(&plat_cap);
+        memcpy_s(misc_attr, sizeof(sgx_misc_attribute_t), &plat_cap,
+                 sizeof(sgx_misc_attribute_t));
+    }
+
+    return ret;
+}
+
+extern "C" sgx_status_t sgx_create_enclave(const char *file_name,
+                                           const int debug,
+                                           sgx_launch_token_t *launch_token,
+                                           int *launch_token_updated,
+                                           sgx_enclave_id_t *enclave_id,
+                                           sgx_misc_attribute_t *misc_attr,
+                                           void **enclave_base_addr,
+                                           bool enable_user_utility)
+{
+    return __sgx_create_enclave_ex(file_name, debug, launch_token, launch_token_updated, enclave_id, misc_attr, 0, NULL, enclave_base_addr, enable_user_utility);
+}
+
+
+extern "C" sgx_status_t sgx_create_enclave_from_buffer(
+        uint8_t *buffer,
+        size_t buffer_size,
+        const int debug,
+        sgx_launch_token_t *launch_token,
+        int *launch_token_updated,
+        sgx_enclave_id_t *enclave_id,
+        sgx_misc_attribute_t *misc_attr,
+        void **enclave_base_addr,
+        bool enable_user_utility)
+{
+    return __sgx_create_enclave_from_buffer_ex(
+        buffer, buffer_size, debug, launch_token, launch_token_updated,
+        enclave_id, misc_attr, 0, NULL, enclave_base_addr, enable_user_utility);
 }
 
 
@@ -128,11 +193,14 @@
                                                sgx_enclave_id_t *enclave_id,
                                                sgx_misc_attribute_t *misc_attr,
                                                const uint32_t ex_features,
-                                               const void* ex_features_p[32])
+                                               const void* ex_features_p[32],
+                                               void **enclave_base_addr,
+                                               bool enable_user_utility)
 {
 
     return __sgx_create_enclave_ex(file_name, debug, launch_token,
-        launch_token_updated, enclave_id, misc_attr, ex_features, ex_features_p);
+        launch_token_updated, enclave_id, misc_attr, ex_features,
+        ex_features_p, enclave_base_addr, enable_user_utility);
 }
 
 
@@ -144,12 +212,32 @@
     int *launch_token_updated,
     sgx_enclave_id_t *enclave_id,
     sgx_misc_attribute_t *misc_attr,
-    uint8_t* sealed_key)
+    uint8_t* sealed_key,
+    void **enclave_base_addr,
+    bool enable_user_utility)
 {
     uint32_t ex_features = SGX_CREATE_ENCLAVE_EX_PCL;
     const void* ex_features_p[32] = { 0 };
     ex_features_p[SGX_CREATE_ENCLAVE_EX_PCL_BIT_IDX] = (void*)sealed_key;
 
     return __sgx_create_enclave_ex(file_name, debug, launch_token,
-        launch_token_updated, enclave_id, misc_attr, ex_features, ex_features_p);
+        launch_token_updated, enclave_id, misc_attr, ex_features,
+        ex_features_p, enclave_base_addr, enable_user_utility);
+}
+
+extern "C" int is_tcs_sim_active(const tcs_t *tcs);
+
+extern "C" int sgx_is_tcs_active(const sgx_enclave_id_t enclave_id)
+{
+// In the non-sim case, tcs cannot be active because untrusted code cannot run
+// when it is active.
+#ifdef SE_SIM
+  CEnclave* enclave = CEnclavePool::instance()->get_enclave(enclave_id);
+  if (enclave)
+  {
+    tcs_t *tcs = enclave->get_tcs_info();
+    return is_tcs_sim_active(tcs);
+  }
+#endif
+  return 0;
 }
diff -Nur psw/urts/loader.cpp psw/urts/loader.cpp
--- psw/urts/loader.cpp
+++ psw/urts/loader.cpp
@@ -47,7 +47,9 @@
 #include <vector>
 #include <tuple>
 #include <algorithm>
+#ifndef __STDC_FORMAT_MACROS
 #define __STDC_FORMAT_MACROS
+#endif  // __STDC_FORMAT_MACROS
 #include <inttypes.h>
 #include <sys/mman.h>
 
@@ -103,7 +105,7 @@
 }
 
 // is_relocation_page returns true if the specified RVA is a writable relocation page based on the bitmap.
-bool CLoader::is_relocation_page(const uint64_t rva, vector<uint8_t> *bitmap)
+bool CLoader::is_relocation_page(const uint64_t rva, std::vector<uint8_t> *bitmap)
 {
     uint64_t page_frame = rva >> SE_PAGE_SHIFT;
     //NOTE:
@@ -181,7 +183,7 @@
     return SGX_SUCCESS;
 }
 
-int CLoader::build_sections(vector<uint8_t> *bitmap)
+int CLoader::build_sections(std::vector<uint8_t> *bitmap)
 {
     int ret = SGX_SUCCESS;
     std::vector<Section*> sections = m_parser.get_sections();
@@ -372,7 +374,7 @@
                 ptcs->ogs_base += rva;
                 if(!(attributes & PAGE_ATTR_EREMOVE))
                 {
-                    m_tcs_list.push_back(make_pair(GET_PTR(tcs_t, m_start_addr, rva), false));
+                    m_tcs_list.push_back(std::make_pair(GET_PTR(tcs_t, m_start_addr, rva), false));
                 }
                 sinfo.flags = layout->si_flags;
                 if(SGX_SUCCESS != (ret = build_pages(rva, ((uint64_t)layout->page_count) << SE_PAGE_SHIFT, added_page, sinfo, attributes)))
@@ -417,7 +419,7 @@
 #ifndef SE_SIM
         if(layout->id == LAYOUT_ID_TCS_DYN)
         {
-            m_tcs_list.push_back(make_pair(GET_PTR(tcs_t, m_start_addr, rva), true));
+            m_tcs_list.push_back(std::make_pair(GET_PTR(tcs_t, m_start_addr, rva), true));
         }
 #endif
     }
@@ -450,7 +452,7 @@
     }
     return SGX_SUCCESS;
 }
-int CLoader::build_secs(sgx_attributes_t * const secs_attr, sgx_misc_attribute_t * const misc_attr)
+int CLoader::build_secs(sgx_attributes_t * const secs_attr, void **enclave_base_addr, sgx_misc_attribute_t * const misc_attr)
 {
     memset(&m_secs, 0, sizeof(secs_t)); //should set resvered field of secs as 0.
     //create secs structure.
@@ -464,19 +466,30 @@
     EnclaveCreator *enclave_creator = get_enclave_creator();
     if(NULL == enclave_creator)
         return SGX_ERROR_UNEXPECTED;
+    if (enclave_base_addr)
+    {
+      // If |enclave_base_addr| is NULL, the address to create the enclave will
+      // be chosen by the kernel by default. Otherwise the enclave is created at
+      // |enclave_base_addr|, unless it's not available.
+      m_start_addr = *enclave_base_addr;
+    }
     int ret = enclave_creator->create_enclave(&m_secs, &m_enclave_id, &m_start_addr, is_ae(&m_metadata->enclave_css));
     if(SGX_SUCCESS == ret)
     {
         SE_TRACE(SE_TRACE_NOTICE, "enclave start address = %p, size = 0x%llx\n", m_start_addr, m_metadata->enclave_size);
+        if (enclave_base_addr)
+        {
+          *enclave_base_addr = m_start_addr;
+        }
     }
     return ret;
 }
-int CLoader::build_image(SGXLaunchToken * const lc, sgx_attributes_t * const secs_attr, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t * const misc_attr)
+int CLoader::build_image(SGXLaunchToken * const lc, sgx_attributes_t * const secs_attr, void **enclave_base_addr, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t * const misc_attr)
 {
     int ret = SGX_SUCCESS;
 
 
-    if(SGX_SUCCESS != (ret = build_secs(secs_attr, misc_attr)))
+    if(SGX_SUCCESS != (ret = build_secs(secs_attr, enclave_base_addr, misc_attr)))
     {
         SE_TRACE(SE_TRACE_WARNING, "build secs failed\n");
         return ret;
@@ -486,7 +499,7 @@
     // If load_enclave_ex try to load the enclave for the 2nd time,
     // the enclave image is already patched, and parser cannot read the information.
     // For linux, there's no map conflict. We assume load_enclave_ex will not do the retry.
-    vector<uint8_t> bitmap;
+    std::vector<uint8_t> bitmap;
     if(!m_parser.get_reloc_bitmap(bitmap))
         return SGX_ERROR_INVALID_ENCLAVE;
 
@@ -564,12 +577,12 @@
 {
     layout_t *layout_start = GET_PTR(layout_t, m_metadata, m_metadata->dirs[DIR_LAYOUT].offset);
     layout_t *layout_end = GET_PTR(layout_t, m_metadata, m_metadata->dirs[DIR_LAYOUT].offset + m_metadata->dirs[DIR_LAYOUT].size);
-    vector<pair<uint64_t, uint64_t>> rva_vector;
+    std::vector<std::pair<uint64_t, uint64_t>> rva_vector;
     for (layout_t *layout = layout_start; layout < layout_end; layout++)
     {
         if(!IS_GROUP_ID(layout->entry.id))  // layout entry
         {
-            rva_vector.push_back(make_pair(layout->entry.rva, ((uint64_t)layout->entry.page_count) << SE_PAGE_SHIFT));
+            rva_vector.push_back(std::make_pair(layout->entry.rva, ((uint64_t)layout->entry.page_count) << SE_PAGE_SHIFT));
             if(layout->entry.content_offset)
             {
                 if(false == is_metadata_buffer(layout->entry.content_offset, layout->entry.content_size))
@@ -598,7 +611,7 @@
                     {
                         return SGX_ERROR_INVALID_METADATA;
                     }
-                    rva_vector.push_back(make_pair(entry->rva + load_step, ((uint64_t)entry->page_count) << SE_PAGE_SHIFT));
+                    rva_vector.push_back(std::make_pair(entry->rva + load_step, ((uint64_t)entry->page_count) << SE_PAGE_SHIFT));
                     // no need to check integer overflow for entry->rva + load_step, because
                     // entry->rva and load_step are less than enclave_size, whose size is no more than 37 bit
                 }
@@ -606,7 +619,7 @@
         }
     }
     sort(rva_vector.begin(), rva_vector.end());
-    for (vector<pair<uint64_t, uint64_t>>::iterator it = rva_vector.begin(); it != rva_vector.end(); it++)
+    for (std::vector<std::pair<uint64_t, uint64_t>>::iterator it = rva_vector.begin(); it != rva_vector.end(); it++)
     {
         if(!IS_PAGE_ALIGNED(it->first))
         {
@@ -710,7 +723,7 @@
     return false;
 }
 
-int CLoader::load_enclave(SGXLaunchToken *lc, int debug, const metadata_t *metadata, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t *misc_attr)
+int CLoader::load_enclave(SGXLaunchToken *lc, int debug, const metadata_t *metadata, void **enclave_base_addr, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t *misc_attr)
 {
     int ret = SGX_SUCCESS;
     sgx_misc_attribute_t sgx_misc_attr;
@@ -730,7 +743,7 @@
         return ret;
     }
 
-    ret = build_image(lc, &sgx_misc_attr.secs_attr, prd_css_file, &sgx_misc_attr);
+    ret = build_image(lc, &sgx_misc_attr.secs_attr, enclave_base_addr, prd_css_file, &sgx_misc_attr);
     // Update misc_attr with secs.attr upon success.
     if(SGX_SUCCESS == ret)
     {
@@ -745,14 +758,14 @@
     return ret;
 }
 
-int CLoader::load_enclave_ex(SGXLaunchToken *lc, bool debug, const metadata_t *metadata, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t *misc_attr)
+int CLoader::load_enclave_ex(SGXLaunchToken *lc, bool debug, const metadata_t *metadata, void **enclave_base_addr, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t *misc_attr)
 {
     unsigned int ret = SGX_SUCCESS, map_conflict_count = 3;
     bool retry = true;
 
     while (retry)
     {
-        ret = this->load_enclave(lc, debug, metadata, prd_css_file, misc_attr);
+        ret = this->load_enclave(lc, debug, metadata, enclave_base_addr, prd_css_file, misc_attr);
         switch(ret)
         {
             //If CreateEnclave failed due to power transition, we retry it.
diff -Nur psw/urts/loader.h psw/urts/loader.h
--- psw/urts/loader.h
+++ psw/urts/loader.h
@@ -57,8 +57,8 @@
 public:
     CLoader(uint8_t *mapped_file_base, BinParser &parser);
     virtual ~CLoader();
-    int load_enclave(SGXLaunchToken *lc, int flag, const metadata_t *metadata, le_prd_css_file_t *prd_css_file = NULL, sgx_misc_attribute_t *misc_attr = NULL);
-    int load_enclave_ex(SGXLaunchToken *lc, bool is_debug, const metadata_t *metadata, le_prd_css_file_t *prd_css_file = NULL, sgx_misc_attribute_t *misc_attr = NULL);
+    int load_enclave(SGXLaunchToken *lc, int debug, const metadata_t *metadata, void **enclave_base_addr, le_prd_css_file_t *prd_css_file = NULL, sgx_misc_attribute_t *misc_attr = NULL);
+    int load_enclave_ex(SGXLaunchToken *lc, bool is_debug, const metadata_t *metadata, void **enclave_base_addr, le_prd_css_file_t *prd_css_file = NULL, sgx_misc_attribute_t *misc_attr = NULL);
     int destroy_enclave();
     sgx_enclave_id_t get_enclave_id() const;
     const void* get_start_addr() const;
@@ -71,13 +71,13 @@
 
 private:
     int build_mem_region(const section_info_t &sec_info);
-    int build_image(SGXLaunchToken * const lc, sgx_attributes_t * const secs_attr, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t * const misc_attr);
-    int build_secs(sgx_attributes_t * const secs_attr, sgx_misc_attribute_t * const misc_attr);
+    int build_image(SGXLaunchToken * const lc, sgx_attributes_t * const secs_attr, void **enclave_base_addr, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t * const misc_attr);
+    int build_secs(sgx_attributes_t * const secs_attr, void **enclave_base_addr, sgx_misc_attribute_t * const misc_attr);
     int build_context(const uint64_t start_rva, layout_entry_t *layout);
     int build_contexts(layout_t *layout_start, layout_t *layout_end, uint64_t delta);
     int build_partial_page(const uint64_t rva, const uint64_t size, const void *source, const sec_info_t &sinfo, const uint32_t attr);
     int build_pages(const uint64_t start_rva, const uint64_t size, const void *source, const sec_info_t &sinfo, const uint32_t attr);
-    bool is_relocation_page(const uint64_t rva, vector<uint8_t> *bitmap);
+    bool is_relocation_page(const uint64_t rva, std::vector<uint8_t> *bitmap);
 
     bool is_ae(const enclave_css_t *enclave_css);
     bool is_metadata_buffer(uint32_t offset, uint32_t size);
@@ -86,7 +86,7 @@
     int validate_patch_table();
     int validate_metadata();
     int get_debug_flag(const token_t * const launch);
-    virtual int build_sections(vector<uint8_t> *bitmap);
+    virtual int build_sections(std::vector<uint8_t> *bitmap);
     int set_context_protection(layout_t *layout_start, layout_t *layout_end, uint64_t delta);
 
     uint8_t             *m_mapped_file_base;
diff -Nur psw/urts/parser/binparser.h psw/urts/parser/binparser.h
--- psw/urts/parser/binparser.h
+++ psw/urts/parser/binparser.h
@@ -41,8 +41,6 @@
 #include <stdint.h>
 #include <vector>
 #include <string>
-using std::vector;
-using std::string;
 
 #define ENCLAVE_MAX_SIZE_32 0xffffffff
 #define ENCLAVE_MAX_SIZE_64 0x1fffffffff
@@ -77,17 +75,17 @@
     virtual const uint8_t* get_start_addr() const = 0;
 
     // Get a vector of sections to be loaded
-    virtual const vector<Section *>& get_sections() const = 0;
+    virtual const std::vector<Section *>& get_sections() const = 0;
 
     // Get the TLS section
     virtual const Section* get_tls_section() const = 0;
 
     virtual uint64_t get_symbol_rva(const char* name) const = 0;
 
-    virtual bool get_reloc_bitmap(vector<uint8_t> &bitmap) = 0;
+    virtual bool get_reloc_bitmap(std::vector<uint8_t> &bitmap) = 0;
 
     virtual void get_reloc_entry_offset(const char* sec_name,
-                                        vector<uint64_t>& offsets) = 0;
+                                        std::vector<uint64_t>& offsets) = 0;
 
     // !We need to put this method into BinParser class since
     // !the `global_data_t' is platform-dependent as the parser.
@@ -107,7 +105,7 @@
 
     virtual sgx_status_t get_info(enclave_diff_info_t *enclave_diff_info) = 0;
 
-    virtual void get_executable_sections(vector<const char *>& xsec_names) const = 0;
+    virtual void get_executable_sections(std::vector<const char *>& xsec_names) const = 0;
     virtual bool set_memory_protection(uint64_t enclave_base_addr, bool is_after_initialization) = 0;
     virtual void get_pages_to_protect(uint64_t, std::vector<std::tuple<uint64_t, uint64_t, uint32_t>>&) const = 0;
     virtual bool has_init_section() const = 0;
diff -Nur psw/urts/parser/elfparser.cpp psw/urts/parser/elfparser.cpp
--- psw/urts/parser/elfparser.cpp
+++ psw/urts/parser/elfparser.cpp
@@ -184,7 +184,7 @@
  * We only need to search `.dynsym' for undefined symbols.
  */
 bool check_symbol_table(const ElfW(Ehdr) *elf_hdr, const ElfW(Dyn) *dyn_info,
-                        map<string, uint64_t>& sym_table)
+                        std::map<std::string, uint64_t>& sym_table)
 {
     const ElfW(Shdr) *sh_symtab = get_section_by_addr(elf_hdr, dyn_info[DT_SYMTAB].d_un.d_ptr);
 
@@ -245,7 +245,7 @@
     // If the enclave if compiled/linked with -fpie/-pie, and setting the
     // enclave entry to `enclave_entry', the `st_name' for `enclave_entry'
     // will be 0 in `.dynsym'.
-    map<string, uint64_t>::const_iterator it = sym_table.find("enclave_entry");
+    std::map<std::string, uint64_t>::const_iterator it = sym_table.find("enclave_entry");
     if (it == sym_table.end())
     {
         sym_table["enclave_entry"] = (uint64_t)elf_hdr->e_entry;
@@ -504,7 +504,7 @@
 }
 
 bool build_regular_sections(const uint8_t* start_addr,
-                            vector<Section *>& sections,
+                            std::vector<Section *>& sections,
                             const Section*& tls_sec,
                             uint64_t& metadata_offset,
                             uint64_t& metadata_block_size)
@@ -565,7 +565,7 @@
     return true;
 }
 
-const Section* get_max_rva_section(const vector<Section*> sections)
+const Section* get_max_rva_section(const std::vector<Section*> sections)
 {
     size_t sec_size = sections.size();
 
@@ -672,7 +672,7 @@
     return m_start_addr;
 }
 
-const vector<Section *>& ElfParser::get_sections() const
+const std::vector<Section *>& ElfParser::get_sections() const
 {
     return m_sections;
 }
@@ -684,7 +684,7 @@
 
 uint64_t ElfParser::get_symbol_rva(const char* name) const
 {
-    map<string, uint64_t>::const_iterator it = m_sym_table.find(name);
+  std::map<std::string, uint64_t>::const_iterator it = m_sym_table.find(name);
     if (it != m_sym_table.end())
         return it->second;
     else
@@ -700,7 +700,7 @@
     return false;
 }
 
-bool ElfParser::get_reloc_bitmap(vector<uint8_t>& bitmap)
+bool ElfParser::get_reloc_bitmap(std::vector<uint8_t>& bitmap)
 {
     // Clear the `bitmap' so that it is in a known state
     bitmap.clear();
@@ -781,7 +781,7 @@
     return true;
 }
 
-void ElfParser::get_reloc_entry_offset(const char* sec_name, vector<uint64_t>& offsets)
+void ElfParser::get_reloc_entry_offset(const char* sec_name, std::vector<uint64_t>& offsets)
 {
     if (sec_name == NULL)
         return;
@@ -844,6 +844,18 @@
         return false;
     }
     *data_size = sizeof(global_data_t);
+
+    // Record the data and bss section address and size.
+    global_data_t *global_data = reinterpret_cast<global_data_t *>(data);
+    const ElfW(Ehdr) *elf_hdr = reinterpret_cast<const ElfW(Ehdr) *>(m_start_addr);
+    const ElfW(Shdr) *shdr = get_section_by_name(elf_hdr, ELF_DATA);
+    global_data->data_offset = static_cast<sys_word_t>(shdr->sh_addr);
+    global_data->data_size = static_cast<sys_word_t>(shdr->sh_size);
+
+    shdr = get_section_by_name(elf_hdr, ELF_BSS);
+    global_data->bss_offset = static_cast<sys_word_t>(shdr->sh_addr);
+    global_data->bss_size = static_cast<sys_word_t>(shdr->sh_size);
+
     return do_update_global_data(metadata, create_param, (global_data_t *)data);
 }
 
@@ -859,7 +871,7 @@
     return SGX_SUCCESS;
 }
 
-void ElfParser::get_executable_sections(vector<const char *>& xsec_names) const
+void ElfParser::get_executable_sections(std::vector<const char *>& xsec_names) const
 {
     xsec_names.clear();
 
diff -Nur psw/urts/parser/elfparser.h psw/urts/parser/elfparser.h
--- psw/urts/parser/elfparser.h
+++ psw/urts/parser/elfparser.h
@@ -39,9 +39,6 @@
 #include <string>
 #include <map>
 
-using std::map;
-using std::string;
-
 class ElfParser : public BinParser, private Uncopyable {
 public:
     // The `start_addr' cannot be NULL
@@ -63,11 +60,11 @@
 
     // The `section' here is a section in PE's concept.
     // It is in fact a `segment' in ELF's view.
-    const vector<Section *>& get_sections() const;
+    const std::vector<Section *>& get_sections() const;
     const Section* get_tls_section() const;
     uint64_t get_symbol_rva(const char* name) const;
 
-    bool get_reloc_bitmap(vector<uint8_t> &bitmap);
+    bool get_reloc_bitmap(std::vector<uint8_t> &bitmap);
     bool has_text_reloc() const;
     uint32_t get_global_data_size();
     bool update_global_data(const metadata_t *const metadata,
@@ -86,11 +83,11 @@
     // To check whether current enclave has any TEXTREL:
     //   get_reloc_entry_offset(".text", offsets);
     void get_reloc_entry_offset(const char* sec_name,
-                                vector<uint64_t>& offsets);
+                                std::vector<uint64_t>& offsets);
 
     sgx_status_t modify_info(enclave_diff_info_t *enclave_diff_info);
     sgx_status_t get_info(enclave_diff_info_t *enclave_diff_info);
-    void get_executable_sections(vector<const char *>& xsec_names) const;
+    void get_executable_sections(std::vector<const char *>& xsec_names) const;
     bool is_enclave_encrypted() const;
 
     bool set_memory_protection(uint64_t enclave_base_addr, bool is_after_initialization);
@@ -102,7 +99,7 @@
     const uint8_t*      m_start_addr;
     uint64_t            m_len;
     bin_fmt_t           m_bin_fmt;
-    vector<Section *>   m_sections;
+    std::vector<Section *>   m_sections;
     const Section*      m_tls_section;
     uint64_t            m_metadata_offset;
     uint64_t            m_metadata_block_size;/*multiple metadata block size*/
@@ -110,7 +107,7 @@
     ElfW(Dyn)           m_dyn_info[DT_NUM + DT_ADDRNUM];
 
     // A map from symbol name to its RVA
-    map<string, uint64_t> m_sym_table;
+    std::map<std::string, uint64_t> m_sym_table;
 };
 
 #endif
diff -Nur psw/urts/parser/update_global_data.hxx psw/urts/parser/update_global_data.hxx
--- psw/urts/parser/update_global_data.hxx
+++ psw/urts/parser/update_global_data.hxx
@@ -29,6 +29,13 @@
  *
  */
 
+#include <stdint.h>
+
+#include "create_param.h"
+#include "global_data.h"
+#include "loader.h"
+#include "thread_data.h"
+
 namespace {
     layout_entry_t *get_entry_by_id(const metadata_t *const metadata, uint16_t id)
     {
diff -Nur psw/urts/routine.cpp psw/urts/routine.cpp
--- psw/urts/routine.cpp
+++ psw/urts/routine.cpp
@@ -37,7 +37,7 @@
 #include "rts_cmd.h"
 
 static
-sgx_status_t _sgx_ecall(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms, const bool is_switchless)
+sgx_status_t _sgx_ecall(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms, bool is_utility, const bool is_switchless)
 {
     if ((proc != ECMD_RUN_SWITCHLESS_TWORKER) &&  (proc < 0))
     {
@@ -52,7 +52,7 @@
 
     sgx_status_t result = SGX_ERROR_UNEXPECTED;
     {
-        result = enclave->ecall(proc, ocall_table, ms, is_switchless);
+        result = enclave->ecall(proc, ocall_table, ms, is_utility, is_switchless);
     }
     {
         //This solution seems more readable and easy to validate, but low performace
@@ -63,15 +63,15 @@
 }
 
 extern "C"
-sgx_status_t sgx_ecall(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms)
+sgx_status_t sgx_ecall(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms, bool is_utility)
 {
-    return _sgx_ecall(enclave_id, proc, ocall_table, ms, false);
+    return _sgx_ecall(enclave_id, proc, ocall_table, ms, is_utility, false);
 }
 
 extern "C"
-sgx_status_t sgx_ecall_switchless(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms)
+sgx_status_t sgx_ecall_switchless(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms, bool is_utility)
 {
-    return _sgx_ecall(enclave_id, proc, ocall_table, ms, true);
+    return _sgx_ecall(enclave_id, proc, ocall_table, ms, is_utility, true);
 }
 
 extern "C"
diff -Nur psw/urts/section_info.h psw/urts/section_info.h
--- psw/urts/section_info.h
+++ psw/urts/section_info.h
@@ -36,8 +36,6 @@
 #include "util.h"
 #include <vector>
 
-using namespace std;
-
 typedef struct _section_info_t
 {
     const uint8_t *raw_data;          //The file pointer to the first page of the section.
@@ -45,7 +43,7 @@
     uint64_t rva;               //The address of the first byte of the section relative to the image base when section is loaded into memory.
     uint64_t virtual_size;      //The total size of the section when loaded into memory.
     si_flags_t flag;            //the attribute of memory region.
-    vector<uint8_t> *bitmap;    //bitmap of the total image page, if bit is 1, the page should be writable.
+    std::vector<uint8_t> *bitmap;    //bitmap of the total image page, if bit is 1, the page should be writable.
     //the first bit of scetion in the bitmap is bitmap[(rva >> PAGE_SHIFT) / 8] & (1 << ((rva >> PAGE_SHIFT) % 8))
     //if the bitmap is NULL, then no restrict on page attribute.
 } section_info_t;
diff -Nur psw/urts/tcs.cpp psw/urts/tcs.cpp
--- psw/urts/tcs.cpp
+++ psw/urts/tcs.cpp
@@ -94,21 +94,23 @@
 {
     m_thread_list = NULL;
     m_utility_thread = NULL;
+    m_user_utility_thread = NULL;
     m_tcs_min_pool = tcs_min_pool;
     m_need_to_wait_for_new_thread = false;
+    m_user_utility_thread_in_use = false;
 }
 
 CTrustThreadPool::~CTrustThreadPool()
 {
     LockGuard lock(&m_thread_mutex);
     //destroy free tcs list
-    for(vector<CTrustThread *>::iterator it=m_free_thread_vector.begin(); it!=m_free_thread_vector.end(); it++)
+    for(std::vector<CTrustThread *>::iterator it=m_free_thread_vector.begin(); it!=m_free_thread_vector.end(); it++)
     {
         delete *it;
     }
     m_free_thread_vector.clear();
     //destroy unallocated tcs list
-    for(vector<CTrustThread *>::iterator it=m_unallocated_threads.begin(); it!=m_unallocated_threads.end(); it++)
+    for(std::vector<CTrustThread *>::iterator it=m_unallocated_threads.begin(); it!=m_unallocated_threads.end(); it++)
     {
         delete *it;
     }
@@ -130,13 +132,17 @@
         delete m_utility_thread;
         m_utility_thread = NULL;
     }
-
+    if (m_user_utility_thread)
+    {
+        delete m_user_utility_thread;
+        m_user_utility_thread = NULL;
+    }
 }
 
-void get_thread_set(vector<se_thread_id_t> &thread_vector);
-inline int CTrustThreadPool::find_thread(vector<se_thread_id_t> &thread_vector, se_thread_id_t thread_id)
+void get_thread_set(std::vector<se_thread_id_t> &thread_vector);
+inline int CTrustThreadPool::find_thread(std::vector<se_thread_id_t> &thread_vector, se_thread_id_t thread_id)
 {
-    for(vector<se_thread_id_t>::iterator it=thread_vector.begin(); it!=thread_vector.end(); it++)
+    for(std::vector<se_thread_id_t>::iterator it=thread_vector.begin(); it!=thread_vector.end(); it++)
         if(*it == thread_id)
             return TRUE;
     return FALSE;
@@ -209,7 +215,7 @@
     return trust_thread;
 }
 
-CTrustThread * CTrustThreadPool::add_thread(tcs_t * const tcs, CEnclave * const enclave, bool is_unallocated)
+CTrustThread * CTrustThreadPool::add_thread(tcs_t * const tcs, CEnclave * const enclave, bool is_unallocated, bool enable_user_utility)
 {
     CTrustThread *trust_thread = new CTrustThread(tcs, enclave);
     LockGuard lock(&m_thread_mutex);
@@ -218,6 +224,8 @@
     {
         if (g_enclave_creator->is_EDMM_supported(enclave->get_enclave_id()) && !m_utility_thread && (enclave->get_dynamic_tcs_list_size() != 0))
             m_utility_thread = trust_thread;
+        else if (enable_user_utility && !m_user_utility_thread)
+            m_user_utility_thread = trust_thread;
         else
             m_free_thread_vector.push_back(trust_thread);
     }
@@ -252,9 +260,9 @@
 {
     LockGuard lock(&m_thread_mutex);
 
-    vector<CTrustThread *> threads;
+    std::vector<CTrustThread *> threads;
 
-    for(vector<CTrustThread *>::iterator it = m_free_thread_vector.begin(); it != m_free_thread_vector.end(); it++)
+    for(std::vector<CTrustThread *>::iterator it = m_free_thread_vector.begin(); it != m_free_thread_vector.end(); it++)
     {
         threads.push_back(*it);
     }
@@ -309,7 +317,7 @@
     //try to get tcs from thread cache
     se_thread_id_t thread_id = get_thread_id();
     CTrustThread *trust_thread = get_bound_thread(thread_id);
-    if(NULL != trust_thread  && m_utility_thread != trust_thread)
+    if(NULL != trust_thread && m_utility_thread != trust_thread && m_user_utility_thread != trust_thread)
     {
         return trust_thread;
     }
@@ -334,7 +342,7 @@
     LockGuard lock(&m_thread_mutex);
     CTrustThread *trust_thread = NULL;
     bool is_special_ecall = (ecall_cmd == ECMD_INIT_ENCLAVE) || (ecall_cmd == ECMD_UNINIT_ENCLAVE) ;
-    
+    bool is_user_utility = (ecall_cmd == ECMD_UTILITY);
 
     if(is_special_ecall == true)
     {
@@ -357,6 +365,21 @@
             trust_thread = _acquire_thread();
         }
     }
+    else if (is_user_utility)
+    {
+        if (m_user_utility_thread)
+        {
+            if (m_user_utility_thread_in_use.exchange(true))
+            {
+                return NULL;
+            }
+            trust_thread = m_user_utility_thread;
+            assert(trust_thread != NULL);
+        } else
+        {
+            return NULL;
+        }
+    }
     else
     {
         trust_thread = _acquire_thread();
@@ -392,6 +415,10 @@
 //Do nothing for bind mode, the tcs is always bound to a thread.
 void CTrustThreadPool::release_thread(CTrustThread * const trust_thread)
 {
+    if (trust_thread == m_user_utility_thread)
+    {
+        m_user_utility_thread_in_use = false;
+    }
     LockGuard lock(&m_thread_mutex);
     trust_thread->decrease_ref();
     return;
@@ -533,7 +560,7 @@
 
     //if free list is NULL, recycle tcs.
     //get thread id set of current process
-    vector<se_thread_id_t> thread_vector;
+    std::vector<se_thread_id_t> thread_vector;
     get_thread_set(thread_vector);
     //walk through thread cache to see if there is any thread that has exited
     Node<se_thread_id_t, CTrustThread*>* it = m_thread_list, *pre = NULL, *tmp = NULL;
diff -Nur psw/urts/tcs.h psw/urts/tcs.h
--- psw/urts/tcs.h
+++ psw/urts/tcs.h
@@ -38,11 +38,10 @@
 #include "sgx_error.h"
 #include "se_debugger_lib.h"
 #include "se_lock.hpp"
+#include <atomic>
 #include <vector>
 #include "node.h"
 
-using namespace std;
-
 typedef int (*bridge_fn_t)(const void*);
 
 class CEnclave;
@@ -77,7 +76,7 @@
     virtual ~CTrustThreadPool();
     CTrustThread * acquire_thread(int ecall_cmd);
     void release_thread(CTrustThread * const trust_thread);
-    CTrustThread *add_thread(tcs_t * const tcs, CEnclave * const enclave, bool is_unallocated);
+    CTrustThread *add_thread(tcs_t * const tcs, CEnclave * const enclave, bool is_unallocated, bool enable_user_utility);
     CTrustThread *get_bound_thread(const tcs_t *tcs);
     std::vector<CTrustThread *> get_thread_list();
     void reset();
@@ -88,15 +87,15 @@
     bool is_dynamic_thread_exist();
 protected:
     virtual int garbage_collect() = 0;
-    inline int find_thread(vector<se_thread_id_t> &thread_vector, se_thread_id_t thread_id);
+    inline int find_thread(std::vector<se_thread_id_t> &thread_vector, se_thread_id_t thread_id);
     inline CTrustThread * get_free_thread();
     int bind_thread(const se_thread_id_t thread_id, CTrustThread * const trust_thread);
     void unbind_thread(const se_thread_id_t thread_id);
     CTrustThread * get_bound_thread(const se_thread_id_t thread_id);
     void add_to_free_thread_vector(CTrustThread* it);
     
-    vector<CTrustThread *>                  m_free_thread_vector;
-    vector<CTrustThread *>                  m_unallocated_threads; 
+    std::vector<CTrustThread *>                  m_free_thread_vector;
+    std::vector<CTrustThread *>                  m_unallocated_threads; 
     Node<se_thread_id_t, CTrustThread *>    *m_thread_list;
     Mutex                                   m_thread_mutex; //protect thread_cache list. The mutex is recursive.
                                                             //Thread can operate the list when it get the mutex
@@ -105,8 +104,10 @@
 private:
     CTrustThread * _acquire_thread();
     CTrustThread *m_utility_thread;
+    CTrustThread *m_user_utility_thread;
     uint64_t     m_tcs_min_pool;
     bool         m_need_to_wait_for_new_thread;
+    std::atomic_bool m_user_utility_thread_in_use;
 };
 
 class CThreadPoolBindMode : public CTrustThreadPool
diff -Nur psw/urts/urts_com.h psw/urts/urts_com.h
--- psw/urts/urts_com.h
+++ psw/urts/urts_com.h
@@ -189,6 +189,8 @@
                             se_file_t& file, 
                             const bool debug, 
                             SGXLaunchToken *lc, 
+                            void **enclave_base_addr,
+                            bool enable_user_utility,
                             le_prd_css_file_t *prd_css_file, 
                             sgx_enclave_id_t *enclave_id, 
                             sgx_misc_attribute_t *misc_attr,
@@ -201,7 +203,7 @@
     int ret = SGX_SUCCESS;
     CLoader loader(base_addr, parser);
 
-    ret = loader.load_enclave_ex(lc, debug, metadata, prd_css_file, misc_attr);
+    ret = loader.load_enclave_ex(lc, debug, metadata, enclave_base_addr, prd_css_file, misc_attr);
     if (ret != SGX_SUCCESS)
     {
         return ret;
@@ -263,7 +265,7 @@
     std::vector<std::pair<tcs_t *, bool>> tcs_list = loader.get_tcs_list();
     for (unsigned idx = 0; idx < tcs_list.size(); ++idx)
     {
-        enclave->add_thread(tcs_list[idx].first, tcs_list[idx].second);
+        enclave->add_thread(tcs_list[idx].first, tcs_list[idx].second, enable_user_utility);
         SE_TRACE(SE_TRACE_DEBUG, "add tcs %p\n", tcs_list[idx].first);
     }
     
@@ -423,32 +425,30 @@
 }
 
 
-sgx_status_t _create_enclave_ex(const bool debug, se_file_handle_t pfile, se_file_t& file, le_prd_css_file_t *prd_css_file, 
-	                            sgx_launch_token_t *launch, int *launch_updated, sgx_enclave_id_t *enclave_id, 
-                                sgx_misc_attribute_t *misc_attr, const uint32_t ex_features, const void* ex_features_p[32])
+
+sgx_status_t _create_enclave_ex_internal(
+        uint8_t *base_addr,
+        uint64_t file_size,
+        const bool debug,
+        se_file_t& file,
+        void **enclave_base_addr,
+        bool enable_user_utility,
+        le_prd_css_file_t *prd_css_file,
+        sgx_launch_token_t *launch,
+        int *launch_updated,
+        sgx_enclave_id_t *enclave_id,
+        sgx_misc_attribute_t *misc_attr,
+        const uint32_t ex_features,
+        const void* ex_features_p[32])
 {
     unsigned int ret = SGX_SUCCESS;
     sgx_status_t lt_result = SGX_SUCCESS;
-    uint32_t file_size = 0;
-    map_handle_t* mh = NULL;
     sgx_misc_attribute_t sgx_misc_attr;
     metadata_t *metadata = NULL;
     SGXLaunchToken *lc = NULL;
     memset(&sgx_misc_attr, 0, sizeof(sgx_misc_attribute_t));
 
-    if(NULL == launch || NULL == launch_updated || NULL == enclave_id)
-        return SGX_ERROR_INVALID_PARAMETER;
-#ifndef SE_SIM
-    ret = validate_platform();
-    if(ret != SGX_SUCCESS)
-        return (sgx_status_t)ret;
-#endif
-
-    mh = map_file(pfile, &file_size);
-    if (!mh)
-        return SGX_ERROR_OUT_OF_MEMORY;
-
-    PARSER parser(const_cast<uint8_t *>(mh->base_addr), (uint64_t)(file_size));
+    PARSER parser(base_addr, file_size);
     if(SGX_SUCCESS != (ret = parser.run_parser()))
     {
         goto clean_return;
@@ -516,7 +516,7 @@
 
     //Need to set the whole misc_attr instead of just secs_attr.
     do {
-        ret = __create_enclave(parser, mh->base_addr, metadata, file, debug, lc, prd_css_file, enclave_id, misc_attr, ex_features, ex_features_p);
+        ret = __create_enclave(parser, base_addr, metadata, file, debug, lc, enclave_base_addr, enable_user_utility, prd_css_file, enclave_id, misc_attr, ex_features, ex_features_p);
         //SGX_ERROR_ENCLAVE_LOST caused by initializing enclave while power transition occurs
     } while(SGX_ERROR_ENCLAVE_LOST == ret);
 
@@ -541,17 +541,80 @@
 
 
 clean_return:
-    if(mh != NULL)
-        unmap_file(mh);
     if(lc != NULL)
         delete lc;
     return (sgx_status_t)ret;
 }
 
-sgx_status_t _create_enclave(const bool debug, se_file_handle_t pfile, se_file_t& file, le_prd_css_file_t *prd_css_file, 
-                             sgx_launch_token_t *launch, int *launch_updated, sgx_enclave_id_t *enclave_id, sgx_misc_attribute_t *misc_attr) 
+
+sgx_status_t _create_enclave_ex(const bool debug, se_file_handle_t pfile, se_file_t& file, void **enclave_base_addr,
+                                bool enable_user_utility, le_prd_css_file_t *prd_css_file, sgx_launch_token_t *launch,
+                                int *launch_updated, sgx_enclave_id_t *enclave_id, sgx_misc_attribute_t *misc_attr,
+                                const uint32_t ex_features, const void* ex_features_p[32])
+{
+    unsigned int ret = SGX_SUCCESS;
+    uint32_t file_size = 0;
+    map_handle_t* mh = NULL;
+
+    if(NULL == launch || NULL == launch_updated || NULL == enclave_id)
+        return SGX_ERROR_INVALID_PARAMETER;
+#ifndef SE_SIM
+    ret = validate_platform();
+    if(ret != SGX_SUCCESS)
+        return (sgx_status_t)ret;
+#endif
+
+    mh = map_file(pfile, &file_size);
+    if (!mh)
+        return SGX_ERROR_OUT_OF_MEMORY;
+
+    ret = _create_enclave_ex_internal(
+            mh->base_addr, (uint64_t)file_size, debug, file, enclave_base_addr, enable_user_utility, prd_css_file, launch,
+            launch_updated, enclave_id, misc_attr, ex_features, ex_features_p);
+
+    if(mh != NULL)
+        unmap_file(mh);
+    return (sgx_status_t)ret;
+}
+
+sgx_status_t _create_enclave_from_buffer_ex(
+        uint8_t *buffer,
+        size_t buffer_size,
+        const bool debug,
+        se_file_t& file,
+        void **enclave_base_addr,
+        bool enable_user_utility,
+        le_prd_css_file_t *prd_css_file,
+        sgx_launch_token_t *launch,
+        int *launch_updated,
+        sgx_enclave_id_t *enclave_id,
+        sgx_misc_attribute_t *misc_attr,
+        const uint32_t ex_features,
+        const void* ex_features_p[32])
+{
+    unsigned int ret = SGX_SUCCESS;
+
+    if(NULL == buffer || NULL == launch || NULL == launch_updated || NULL == enclave_id)
+        return SGX_ERROR_INVALID_PARAMETER;
+#ifndef SE_SIM
+    ret = validate_platform();
+    if(ret != SGX_SUCCESS)
+        return (sgx_status_t)ret;
+#endif
+
+    ret = _create_enclave_ex_internal(
+            buffer, (uint64_t)buffer_size, debug, file, enclave_base_addr, enable_user_utility,
+            prd_css_file, launch, launch_updated, enclave_id, misc_attr, ex_features, ex_features_p);
+
+    return (sgx_status_t)ret;
+}
+
+sgx_status_t _create_enclave(const bool debug, se_file_handle_t pfile, se_file_t& file, void **enclave_base_addr, bool enable_user_utility,
+                             le_prd_css_file_t *prd_css_file,  sgx_launch_token_t *launch, int *launch_updated, sgx_enclave_id_t *enclave_id,
+                             sgx_misc_attribute_t *misc_attr)
 {
-    return _create_enclave_ex(debug, pfile, file, prd_css_file, launch, launch_updated, enclave_id, misc_attr, 0, NULL);
+    return _create_enclave_ex(debug, pfile, file, enclave_base_addr, enable_user_utility, prd_css_file, launch, launch_updated, enclave_id,
+                              misc_attr, 0, NULL);
 }
 
 
@@ -565,7 +628,7 @@
             debug_enclave_info_t *debug_info = const_cast<debug_enclave_info_t *>(enclave->get_debug_info());
             generate_enclave_debug_event(URTS_EXCEPTION_PREREMOVEENCLAVE, debug_info);
             enclave->destroy_uswitchless();
-            enclave->ecall(ECMD_UNINIT_ENCLAVE, NULL, NULL);
+            enclave->ecall(ECMD_UNINIT_ENCLAVE, NULL, NULL, /*is_utility=*/false);
             CEnclavePool::instance()->unref_enclave(enclave);
         }
     }
diff -Nur psw/uswitchless/sl_workers_untrusted.c psw/uswitchless/sl_workers_untrusted.c
--- psw/uswitchless/sl_workers_untrusted.c
+++ psw/uswitchless/sl_workers_untrusted.c
@@ -206,7 +206,7 @@
     BUG_ON(workers->handle->us_ocall_table == NULL);
     struct sl_uswitchless* handle = workers->handle;
     sgx_ecall(handle->us_enclave_id, ECMD_RUN_SWITCHLESS_TWORKER,
-              handle->us_ocall_table, NULL);
+              handle->us_ocall_table, NULL, /*is_utility=*/false);
     return 0;
 }
 
diff -Nur sdk/edger8r/linux/Ast.ml sdk/edger8r/linux/Ast.ml
--- sdk/edger8r/linux/Ast.ml
+++ sdk/edger8r/linux/Ast.ml
@@ -148,6 +148,11 @@
   | UnionDef  of struct_def
   | EnumDef   of enum_def
 
+(* List of errno values to translate between host and enclave. *)
+type errno_list_type = {
+  errnos: string list;
+}
+
 (* Function declaration. *)
 type func_decl = {
   fname : string;       (* function name. *)
@@ -165,6 +170,8 @@
   tf_fdecl   : func_decl;
   tf_is_priv : bool;   (* private or not, see above comment *)
   tf_is_switchless : bool;
+  tf_is_exception_handler : bool;
+  tf_is_utility : bool;
 }
 
 (* untrust function(aka ocall) declaration. *)
@@ -190,6 +197,7 @@
 type expr =
   | Interface of enclave_func list
   | Composite of composite_type
+  | ErrnoList of errno_list_type
   | Importing of import_decl
   | Include   of string
 
@@ -215,6 +223,7 @@
   include_list : string list;
   import_exprs : import_decl list;
   comp_defs    : composite_type list;
+  errno_list   : errno_list_type list;
   tfunc_decls  : trusted_func   list;
   ufunc_decls  : untrusted_func list;
 }
diff -Nur sdk/edger8r/linux/CodeGen.ml sdk/edger8r/linux/CodeGen.ml
--- sdk/edger8r/linux/CodeGen.ml
+++ sdk/edger8r/linux/CodeGen.ml
@@ -46,6 +46,7 @@
   include_list : string list; (* include another .h *)
   import_exprs : Ast.import_decl list;  (* always empty list after finished reduce_import. *)
   comp_defs    : Ast.composite_type list;
+  errno_list   : Ast.errno_list_type list;
   tfunc_decls  : Ast.trusted_func   list;
   ufunc_decls  : Ast.untrusted_func list;
 }
@@ -75,6 +76,7 @@
     include_list = [];
     import_exprs = [];
     comp_defs    = [];
+    errno_list   = [];
     tfunc_decls  = [];
     ufunc_decls  = []; }
 
@@ -84,6 +86,12 @@
 let is_priv_ecall (tf: Ast.trusted_func) =
   tf.Ast.tf_is_priv
 
+let is_exception_ecall (tf: Ast.trusted_func) =
+  tf.Ast.tf_is_exception_handler
+
+let is_utility_ecall (tf: Ast.trusted_func) =
+  tf.Ast.tf_is_utility
+
 let get_uf_fname (uf: Ast.untrusted_func) =
   uf.Ast.uf_fdecl.Ast.fname
 
@@ -99,6 +107,12 @@
 let tf_list_to_priv_list (tfs: Ast.trusted_func list) =
   List.map is_priv_ecall tfs
 
+let tf_list_to_exception_list (tfs: Ast.trusted_func list) =
+  List.map is_exception_ecall tfs
+
+let tf_list_to_utility_list (tfs: Ast.trusted_func list) =
+  List.map is_utility_ecall tfs
+
 (* Get a list of names of all private ECALLs *)
 let get_priv_ecall_names (tfs: Ast.trusted_func list) =
   List.filter is_priv_ecall tfs |> List.map get_tf_fname
@@ -118,11 +132,13 @@
   let ac_include_list = ref [] in
   let ac_import_exprs = ref [] in
   let ac_comp_defs = ref [] in
+  let ac_errno_list = ref [] in
   let ac_tfunc_decls = ref [] in
   let ac_ufunc_decls = ref [] in
     List.iter (fun ex ->
       match ex with
           Ast.Composite x -> ac_comp_defs := x :: !ac_comp_defs
+        | Ast.ErrnoList x -> ac_errno_list := x :: !ac_errno_list
         | Ast.Include   x -> ac_include_list := x :: !ac_include_list
         | Ast.Importing x -> ac_import_exprs := x :: !ac_import_exprs
         | Ast.Interface xs ->
@@ -138,6 +154,7 @@
       include_list = List.rev !ac_include_list;
       import_exprs = List.rev !ac_import_exprs;
       comp_defs    = List.rev !ac_comp_defs;
+      errno_list   = List.rev !ac_errno_list;
       tfunc_decls  = List.rev !ac_tfunc_decls;
       ufunc_decls  = List.rev !ac_ufunc_decls; }
 
@@ -347,6 +364,62 @@
       | Ast.UnionDef  u -> mk_union_decl  (gen_member_list u.Ast.mlist) u.Ast.sname
       | Ast.EnumDef   e -> mk_enum_def    e
 
+(* Generate the internal errno enum definition. *)
+let gen_errno_enum (el: Ast.errno_list_type list) =
+  let all_errnos = List.fold_left (fun acc l -> acc @ l.Ast.errnos) [] el
+  in
+  let all_sorted = List.sort_uniq compare all_errnos
+  in
+  let errno_list = List.fold_left (fun acc name ->
+                                    acc ^ "\tSGX_ERRNO_" ^ name ^ ",\n")
+                                  "" all_sorted
+  in
+    if all_errnos = [] then "" else
+      sprintf "enum _sgx_errno_bridge_t {\n%s} sgx_errno_bridge_t;\n" errno_list
+
+(* Generate the function to convert errno values to the internal enum. *)
+let gen_errno_to_conv (el: Ast.errno_list_type list) =
+  let all_errnos = List.fold_left (fun acc l -> acc @ l.Ast.errnos) [] el
+  in
+  let all_sorted = List.sort_uniq compare all_errnos
+  in
+  let errno_switch =
+    "\tswitch(value)\n\t{\n" ^
+    List.fold_left (fun acc name ->
+                     acc ^ "\t\tcase " ^ name ^
+                     ":\n\t\t\tvalue = SGX_ERRNO_" ^ name ^
+                     ";\n\t\t\tbreak;\n")
+                   "" all_sorted ^
+    "\t\tdefault:\n\t\t\tvalue |= 0x8000;\n\t\t\tbreak;\n\t}\n"
+    (* The above 0x8000 serves two purposes
+     * 1. Ensures that no host errno values can colide with our enum.
+     *  * Assumes < 32k errno values in enum.
+     * 2. Provides a debugging aide to indicate that errno is host-relative.
+     *)
+  in
+    if all_errnos = [] then "" else
+      sprintf "static int bridge_translate_errno_to_internal(int value)\n{\n%s\
+        \treturn value;\n}\n" errno_switch
+
+(* Generate the function to convert errno values from the internal enum. *)
+let gen_errno_from_conv (el: Ast.errno_list_type list) =
+  let all_errnos = List.fold_left (fun acc l -> acc @ l.Ast.errnos) [] el
+  in
+  let all_sorted = List.sort_uniq compare all_errnos
+  in
+  let errno_switch =
+    "\tswitch(value)\n\t{\n" ^
+    List.fold_left (fun acc name ->
+                      acc ^ "\t\tcase SGX_ERRNO_" ^ name ^
+                      ":\n\t\t\tvalue = " ^ name ^
+                      ";\n\t\t\tbreak;\n")
+                    "" all_sorted ^
+    "\t}\n"
+  in
+    if all_errnos = [] then "" else
+      sprintf "static int bridge_translate_errno_from_internal(int value)\n{\n%s\
+        \treturn value;\n}\n" errno_switch
+
 (* Generate a list of '#include' *)
 let gen_include_list (xs: string list) =
   List.fold_left (fun acc s -> acc ^ sprintf "#include \"%s\"\n" s) "" xs
@@ -391,15 +464,24 @@
 
 (* ---------------------------------------------------------------------- *)
 
+let fold_left4 f arg a b c d =
+  let rec loop arg = function
+    | w::ws, x::xs, y::ys, z::zs -> loop(f arg w x y z) (ws, xs, ys, zs)
+    | [], [], [], [] -> arg
+  in
+  loop arg (a, b, c, d)
+
 (* `gen_ecall_table' is used to generate ECALL table with the following form:
     SGX_EXTERNC const struct {
        size_t nr_ecall;    /* number of ECALLs */
        struct {
            void   *ecall_addr;
            uint8_t is_priv;
+           uint8_t is_exception;
+           uint8_t is_utility;
        } ecall_table [nr_ecall];
    } g_ecall_table = {
-       2, { {sgx_foo, 1}, {sgx_bar, 0} }
+       2, { {sgx_foo, 1, 0, 1}, {sgx_bar, 0, 1, 0} }
    };
 *)
 let gen_ecall_table (tfs: Ast.trusted_func list) =
@@ -407,18 +489,20 @@
   let ecall_table_size = List.length tfs in
   let trusted_fds = tf_list_to_fd_list tfs in
   let priv_bits = tf_list_to_priv_list tfs in
+  let exception_bits = tf_list_to_exception_list tfs in
+  let utility_bits = tf_list_to_utility_list tfs in
   let tbridge_names = List.map (fun (fd: Ast.func_decl) ->
                                   mk_tbridge_name fd.Ast.fname) trusted_fds in
   let ecall_table =
     let bool_to_int b = if b then 1 else 0 in
     let inner_table =
-      List.fold_left2 (fun acc s b ->
-        sprintf "%s\t\t{(void*)(uintptr_t)%s, %d},\n" acc s (bool_to_int b)) "" tbridge_names priv_bits
+      fold_left4 (fun acc s is_priv is_exception_handler is_utility ->
+        sprintf "%s\t\t{(void*)(uintptr_t)%s, %d, %d, %d},\n" acc s (bool_to_int is_priv) (bool_to_int is_exception_handler) (bool_to_int is_utility)) "" tbridge_names priv_bits exception_bits utility_bits
     in "\t{\n" ^ inner_table ^ "\t}\n"
   in
     sprintf "SGX_EXTERNC const struct {\n\
 \tsize_t nr_ecall;\n\
-\tstruct {void* ecall_addr; uint8_t is_priv;} ecall_table[%d];\n\
+\tstruct {void* ecall_addr; uint8_t is_priv; uint8_t is_exception; uint8_t is_utility; } ecall_table[%d];\n\
 } %s = {\n\
 \t%d,\n\
 %s};\n" ecall_table_size
@@ -677,12 +761,18 @@
                                acc ^ ", " ^ mk_parm_name pty dlr) p0 ps)
 
 (* Generate untrusted bridge code for a given untrusted function. *)
-let gen_func_ubridge (file_shortnm: string) (ufunc: Ast.untrusted_func) =
+let gen_func_ubridge (file_shortnm: string) (ufunc: Ast.untrusted_func) (conv_errno: bool) =
   let fd = ufunc.Ast.uf_fdecl in
   let propagate_errno = ufunc.Ast.uf_propagate_errno in
   let func_open = sprintf "%s\n{\n" (mk_ubridge_proto file_shortnm fd.Ast.fname) in
   let func_close = "\treturn SGX_SUCCESS;\n}\n" in
-  let set_errno = if propagate_errno then "\tms->ocall_errno = errno;" else "" in
+  let set_errno =
+    if propagate_errno then "\tms->ocall_errno = " ^
+      if conv_errno then
+        "bridge_translate_errno_to_internal(errno);"
+      else
+        "errno;"
+    else "" in
   let ms_struct_name = mk_ms_struct_name fd.Ast.fname in
   let declare_ms_ptr = sprintf "%s* %s = SGX_CAST(%s*, %s);"
                                ms_struct_name
@@ -741,6 +831,7 @@
 (* Generate untrusted proxy code for a given trusted function. *)
 let gen_func_uproxy (tf: Ast.trusted_func) (idx: int) (ec: enclave_content) =
   let fd = tf.Ast.tf_fdecl in
+  let is_utility = tf.Ast.tf_is_utility in
   let func_open  =
     gen_uproxy_com_proto fd ec.enclave_name ^
       "\n{\n\tsgx_status_t status;\n"
@@ -754,8 +845,8 @@
   let sgx_ecall_fn = get_sgx_fname SGX_ECALL tf.Ast.tf_is_switchless in
 
   (* Normal case - do ECALL with marshaling structure*)
-  let ecall_with_ms = sprintf "status = %s(%s, %d, %s, &%s);"
-                              sgx_ecall_fn eid_name idx ocall_table_ptr ms_struct_val in
+  let ecall_with_ms = sprintf "status = %s(%s, %d, %s, &%s, %s);"
+                              sgx_ecall_fn eid_name idx ocall_table_ptr ms_struct_val (if is_utility then "true" else "false") in
 
   (* Rare case - the trusted function doesn't have parameter nor return value.
    * In this situation, no marshaling structure is required - passing in NULL.
@@ -1372,7 +1463,7 @@
      List.fold_left (fun acc s -> acc ^ s) s2 do_gen_ocalloc_block
 
 (* Generate trusted proxy code for a given untrusted function. *)
-let gen_func_tproxy (ufunc: Ast.untrusted_func) (idx: int) =
+let gen_func_tproxy (ufunc: Ast.untrusted_func) (idx: int) (conv_errno: bool) =
   let fd = ufunc.Ast.uf_fdecl in
   let propagate_errno = ufunc.Ast.uf_propagate_errno in
   let func_open = sprintf "%s\n{\n" (gen_tproxy_proto fd) in
@@ -1435,7 +1526,13 @@
                              Ast.PTVal _ -> acc
                | Ast.PTPtr(ty, attr) -> acc ^ copy_memory attr declr) "" plist in
 
-  let set_errno = if propagate_errno then "\t\terrno = ms->ocall_errno;\n" else "" in
+  let set_errno =
+    if propagate_errno then "\terrno = " ^
+      if conv_errno then
+        "bridge_translate_errno_from_internal(ms->ocall_errno);"
+      else
+        "ms->ocall_errno;"
+    else "" in
   let func_close = sprintf "%s%s%s\n%s%s\n"
                            (handle_out_ptr fd.Ast.plist)
                            set_errno
@@ -1495,12 +1592,16 @@
       ec.tfunc_decls
       (Util.mk_seq 0 (List.length ec.tfunc_decls - 1))
   in
+  let errno_enum = gen_errno_enum ec.errno_list in
+  let errno_conv = gen_errno_to_conv ec.errno_list in
   let ubridge_list =
-    List.map (fun fd -> gen_func_ubridge ec.file_shortnm fd)
+    List.map (fun fd -> gen_func_ubridge ec.file_shortnm fd (errno_enum <> ""))
       (ec.ufunc_decls) in
   let out_chan = open_out code_fname in
     output_string out_chan (include_hd ^ include_errno ^ "\n");
     ms_writer out_chan ec;
+    output_string out_chan (errno_enum ^ "\n");
+    output_string out_chan (errno_conv ^ "\n");
     List.iter (fun s -> output_string out_chan (s ^ "\n")) ubridge_list;
     output_string out_chan (gen_ocall_table ec);
     List.iter (fun s -> output_string out_chan (s ^ "\n")) uproxy_list;
@@ -1537,14 +1638,18 @@
     List.map (fun tfd -> gen_func_tbridge tfd dummy_var) trusted_fds in
   let ecall_table = gen_ecall_table ec.tfunc_decls in
   let entry_table = gen_entry_table ec in
+  let errno_enum = gen_errno_enum ec.errno_list in
+  let errno_conv = gen_errno_from_conv ec.errno_list in
   let tproxy_list = List.map2
-                      (fun fd idx -> gen_func_tproxy fd idx)
+                      (fun fd idx -> gen_func_tproxy fd idx (errno_enum <> ""))
                       (ec.ufunc_decls)
                       (Util.mk_seq 0 (List.length ec.ufunc_decls - 1)) in
   let out_chan = open_out code_fname in
     output_string out_chan (include_hd ^ "\n");
     ms_writer out_chan ec;
     List.iter (fun s -> output_string out_chan (s ^ "\n")) tbridge_list;
+    output_string out_chan (errno_enum ^ "\n");
+    output_string out_chan (errno_conv ^ "\n");
     output_string out_chan (ecall_table ^ "\n");
     output_string out_chan (entry_table ^ "\n");
     output_string out_chan "\n";
@@ -1647,10 +1752,18 @@
   in
     List.iter check_ecall priv_ecall_names
 
-(* Check that there is at least one public ECALL function. *)
-let check_priv_funcs (ec: enclave_content) =
+let rec for_all3 f l1 l2 l3 =
+    match (l1, l2, l3) with
+      ([], [], []) -> true
+    | (a1::l1, a2::l2, a3::l3) -> f a1 a2 a3 && for_all3 f l1 l2 l3
+    | (_, _, _) -> invalid_arg "for_all3"
+
+(* Check that there is at least one public and non exception or utility ECALL function. *)
+let check_priv_and_utility_funcs (ec: enclave_content) =
   let priv_bits = tf_list_to_priv_list ec.tfunc_decls in
-  if List.for_all (fun is_priv -> is_priv) priv_bits
+  let exception_bits = tf_list_to_exception_list ec.tfunc_decls in
+  let utility_bits = tf_list_to_utility_list ec.tfunc_decls in
+  if for_all3 (fun is_priv is_exception_handler is_utility -> is_priv || is_exception_handler || is_utility) priv_bits exception_bits utility_bits
   then failwithf "the enclave `%s' contains no public root ECALL.\n" ec.file_shortnm
   else report_orphaned_priv_ecall ec
 
@@ -1665,7 +1778,7 @@
  *)
 let reduce_import (ec: enclave_content) =
   (* Append a EDL list to another. Keep the first element and replace the
-   second one with empty element contains functions not in the first one 
+   second one with empty element contains functions not in the first one
    if both lists contain a same EDL. The function sequence is backwards compatible.*)
   let join (ec1: enclave_content list) (ec2: enclave_content list) =
     let join_one (acc: enclave_content list) (ec: enclave_content) =
@@ -1743,6 +1856,7 @@
         include_list = acc.include_list @ ec2.include_list;
         import_exprs = [];
         comp_defs    = acc.comp_defs   @ ec2.comp_defs;
+        errno_list   = acc.errno_list  @ ec2.errno_list;
         tfunc_decls  = acc.tfunc_decls @ ec2.tfunc_decls;
         ufunc_decls  = acc.ufunc_decls @ ec2.ufunc_decls; }
   in
@@ -1758,7 +1872,7 @@
     create_dir ep.trusted_dir;
     check_duplication ec;
     check_allow_list ec;
-    (if not ep.header_only then check_priv_funcs ec);
+    (if not ep.header_only then check_priv_and_utility_funcs ec);
     if Plugin.available() then
       Plugin.gen_edge_routines ec ep
     else (
diff -Nur sdk/edger8r/linux/Lexer.mll sdk/edger8r/linux/Lexer.mll
--- sdk/edger8r/linux/Lexer.mll
+++ sdk/edger8r/linux/Lexer.mll
@@ -79,6 +79,9 @@
   | "struct"     { Tstruct }
   | "union"      { Tunion }
   | "enum"       { Tenum }
+  | "errno_list" { Terrno_list }
+  | "exception_handler" { Texception_handler }
+  | "utility_tcs" { Tutility }
 
   (* specifier *)
   | "enclave"    { Tenclave }
diff -Nur sdk/edger8r/linux/Parser.mly sdk/edger8r/linux/Parser.mly
--- sdk/edger8r/linux/Parser.mly
+++ sdk/edger8r/linux/Parser.mly
@@ -305,7 +305,7 @@
 %token Tchar Tshort Tunsigned Tint Tfloat Tdouble
        Tint8 Tint16 Tint32 Tint64
        Tuint8 Tuint16 Tuint32 Tuint64
-       Tsizet Twchar Tvoid Tlong Tstruct Tunion Tenum
+       Tsizet Twchar Tvoid Tlong Tstruct Tunion Tenum Terrno_list Texception_handler Tutility
 %token Tenclave Tfrom Timport Ttrusted Tuntrusted Tallow Tpropagate_errno
 
 %start start_parsing
@@ -529,6 +529,19 @@
   | enum_definition                   { $1 }
   ;
 
+errno_list: Terrno_list TLBrace errno_list_body TRBrace {
+      { Ast.errnos = $3; }
+    }
+  ;
+
+errno_list_body: /* empty */ { [] }
+  | errno_list_eles          { List.rev $1 }
+  ;
+
+errno_list_eles: Tidentifier           { [$1] }
+  | errno_list_eles TComma Tidentifier { $3 :: $1 }
+  ;
+
 member_list: member_def TSemicolon    { [$1] }
   | member_list member_def TSemicolon { $2 :: $1 }
   ;
@@ -591,10 +604,20 @@
   | Tswitchless                      { true  }
   ;
 
+/* is_exception_handler? Default to false */
+exception_handler: /* nothing */ { false }
+  | Texception_handler           { true }
+  ;
+
+/* is_utility? Default to false */
+utility: /* nothing */ { false }
+  | Tutility           { true }
+  ;
+
 trusted_functions: /* nothing */          { [] }
-  | trusted_functions access_modifier func_def switchless_annotation TSemicolon {
-      check_ptr_attr $3 (symbol_start_pos(), symbol_end_pos());
-      Ast.Trusted { Ast.tf_fdecl = $3; Ast.tf_is_priv = $2; Ast.tf_is_switchless = $4 } :: $1
+  | trusted_functions utility exception_handler access_modifier func_def switchless_annotation TSemicolon {
+      check_ptr_attr $5 (symbol_start_pos(), symbol_end_pos());
+      Ast.Trusted { Ast.tf_fdecl = $5; Ast.tf_is_priv = $4; Ast.tf_is_switchless = $6; Ast.tf_is_exception_handler = $3; Ast.tf_is_utility = $2; } :: $1
     }
   ;
 
@@ -665,6 +688,7 @@
   | expressions include_declaration           { Ast.Include($2)   :: $1 }
   | expressions import_declaration TSemicolon { Ast.Importing($2) :: $1 }
   | expressions composite_defs TSemicolon     { Ast.Composite($2) :: $1 }
+  | expressions errno_list TSemicolon         { Ast.ErrnoList($2) :: $1 }
   | expressions enclave_functions             { Ast.Interface($2) :: $1 }
   ;
 
diff -Nur sdk/sign_tool/SignTool/elf_helper.h sdk/sign_tool/SignTool/elf_helper.h
--- sdk/sign_tool/SignTool/elf_helper.h
+++ sdk/sign_tool/SignTool/elf_helper.h
@@ -41,11 +41,9 @@
 
 static void dump_textrel(const uint64_t& offset)
 {
-    using namespace std;
-
-    cerr << "warning: TEXTRELs found at offset: "
-         << std::hex << showbase     /* show the '0x' prefix */
-         << offset << endl;
+    std::cerr << "warning: TEXTRELs found at offset: "
+              << std::hex << std::showbase     /* show the '0x' prefix */
+              << offset << std::endl;
 }
 
 template <int N>
@@ -87,13 +85,13 @@
 
     static bool dump_textrels(BinParser *bp)
     {
-        vector<uint64_t> offsets;
+        std::vector<uint64_t> offsets;
         bool no_rel = true;
         /* The dynamic_cast<> shouldn't fail. */
         elf_parser_t   * p = dynamic_cast<elf_parser_t*>(bp);
         if (p == NULL)
             return no_rel;
-        vector<const char *> sec_names;
+        std::vector<const char *> sec_names;
         p->get_executable_sections(sec_names);
         /* Warn user of TEXTRELs */
         for (unsigned i = 0; i< sec_names.size(); i++)
diff -Nur sdk/sign_tool/SignTool/manage_metadata.cpp sdk/sign_tool/SignTool/manage_metadata.cpp
--- sdk/sign_tool/SignTool/manage_metadata.cpp
+++ sdk/sign_tool/SignTool/manage_metadata.cpp
@@ -55,7 +55,11 @@
 #include <iomanip>
 #include <fstream>
 
-using namespace tinyxml2;
+using tinyxml2::XML_ERROR_FILE_COULD_NOT_BE_OPENED;
+using tinyxml2::XML_ERROR_FILE_NOT_FOUND;
+using tinyxml2::XML_SUCCESS;
+using tinyxml2::XMLElement;
+using tinyxml2::XMLError;
 
 #define ALIGN_SIZE 0x1000
 
@@ -227,7 +231,7 @@
     if(timeinfo  == NULL)
         return false;
     uint32_t tmp_date = (timeinfo->tm_year+1900)*10000 + (timeinfo->tm_mon+1)*100 + timeinfo->tm_mday;
-    stringstream ss;
+    std::stringstream ss;
     ss<<"0x"<<tmp_date;
     ss>>std::hex>>tmp_date;
     *date = tmp_date;
@@ -513,7 +517,7 @@
     guard_page.entry.id = LAYOUT_ID_GUARD;
     guard_page.entry.page_count = SE_GUARD_PAGE_SIZE >> SE_PAGE_SHIFT;
 
-    vector<layout_t> thread_layouts;
+    std::vector<layout_t> thread_layouts;
     // heap
     layout.entry.id = LAYOUT_ID_HEAP_MIN;
     layout.entry.page_count = (uint32_t)(m_create_param.heap_min_size >> SE_PAGE_SHIFT);
@@ -702,7 +706,7 @@
     }
     return true;
 }
-bool CMetadata::build_patch_entries(vector<patch_entry_t> &patches)
+bool CMetadata::build_patch_entries(std::vector<patch_entry_t> &patches)
 {
     uint32_t size = (uint32_t)(patches.size() * sizeof(patch_entry_t));
     patch_entry_t *patch_table = (patch_entry_t *) alloc_buffer_from_metadata(size);
@@ -724,7 +728,7 @@
 bool CMetadata::build_patch_table()
 {
     const uint8_t *base_addr = (const uint8_t *)m_parser->get_start_addr();
-    vector<patch_entry_t> patches;
+    std::vector<patch_entry_t> patches;
     patch_entry_t patch;
     memset(&patch, 0, sizeof(patch));
 
diff -Nur sdk/sign_tool/SignTool/manage_metadata.h sdk/sign_tool/SignTool/manage_metadata.h
--- sdk/sign_tool/SignTool/manage_metadata.h
+++ sdk/sign_tool/SignTool/manage_metadata.h
@@ -100,7 +100,7 @@
     bool build_patch_table();
     bool update_layout_entries();
     bool build_layout_entries();
-    bool build_patch_entries(vector<patch_entry_t> &patches);
+    bool build_patch_entries(std::vector<patch_entry_t> &patches);
 
     layout_entry_t *get_entry_by_id(uint16_t id);
     bool build_tcs_template(tcs_t *tcs);
@@ -113,7 +113,7 @@
     metadata_t *m_metadata;
     BinParser *m_parser;
     create_param_t m_create_param;
-    vector <layout_t> m_layouts;
+    std::vector <layout_t> m_layouts;
     uint64_t m_rva;
     uint32_t m_gd_size;
     uint8_t *m_gd_template;
diff -Nur sdk/simulation/driver_api/driver_api.cpp sdk/simulation/driver_api/driver_api.cpp
--- sdk/simulation/driver_api/driver_api.cpp
+++ sdk/simulation/driver_api/driver_api.cpp
@@ -67,6 +67,7 @@
     memset(&pinfo, 0, sizeof(pinfo));
     pinfo.src_page = secs;
     pinfo.sec_info = &sinfo;
+    pinfo.lin_addr = *start_addr;
 
     ce = reinterpret_cast<CEnclaveSim*>(DoECREATE_SW(&pinfo));
     if (ce == NULL) {
diff -Nur sdk/simulation/SEConfigureCPUSVN/linux/config_cpusvn.cpp sdk/simulation/SEConfigureCPUSVN/linux/config_cpusvn.cpp
--- sdk/simulation/SEConfigureCPUSVN/linux/config_cpusvn.cpp
+++ sdk/simulation/SEConfigureCPUSVN/linux/config_cpusvn.cpp
@@ -49,13 +49,11 @@
 #include <string>
 #include <sstream>
 
-using namespace std;
-
 static void convert_cpusvn_to_string(sgx_cpu_svn_t &cpusvn, string &str)
 {
     uint32_t buffer[4];
     memcpy_s(&buffer, sizeof(uint32_t)*4, &cpusvn, sizeof(sgx_cpu_svn_t));
-    stringstream ss;
+    std::stringstream ss;
     for(int i=0; i<4; i++)
     {
         buffer[i] = __builtin_bswap32(buffer[i]);
diff -Nur sdk/simulation/uinst/u_instructions.cpp sdk/simulation/uinst/u_instructions.cpp
--- sdk/simulation/uinst/u_instructions.cpp
+++ sdk/simulation/uinst/u_instructions.cpp
@@ -154,7 +154,7 @@
 
     // `ce' is not checked against NULL, since it is not
     // allocated with new(std::no_throw).
-    addr = se_virtual_alloc(NULL, (size_t)secs->size, MEM_COMMIT);
+    addr = se_virtual_alloc(pi->lin_addr, (size_t)secs->size, MEM_COMMIT);
     if (addr == NULL) {
         delete ce;
         return 0;
diff -Nur sdk/simulation/urtssim/enclave_creator_sim.cpp sdk/simulation/urtssim/enclave_creator_sim.cpp
--- sdk/simulation/urtssim/enclave_creator_sim.cpp
+++ sdk/simulation/urtssim/enclave_creator_sim.cpp
@@ -246,7 +246,7 @@
     get_cpu_features(&info.cpu_features, (unsigned int*)info.cpuinfo_table);
     info.version = SDK_VERSION_1_5;
     info.sealed_key = enclave->get_sealed_key();
-    status = enclave->ecall(ECMD_INIT_ENCLAVE, NULL, reinterpret_cast<void *>(&info));
+    status = enclave->ecall(ECMD_INIT_ENCLAVE, NULL, reinterpret_cast<void *>(&info), /*is_utility=*/false);
     //free the tcs used by initialization;
     enclave->get_thread_pool()->reset();
     if(SGX_SUCCESS == status)
diff -Nur sdk/simulation/urtssim/get_state.cpp sdk/simulation/urtssim/get_state.cpp
--- sdk/simulation/urtssim/get_state.cpp
+++ sdk/simulation/urtssim/get_state.cpp
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2011-2017 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+#include "td_mngr.h"
+
+extern "C" int is_tcs_sim_active(const tcs_t *tcs)
+{
+  if (tcs)
+  {
+    tcs_sim_t* tcs_sim = (tcs_sim_t*)(tcs->reserved);
+    if (tcs_sim)
+      return (tcs_sim->tcs_state == TCS_STATE_ACTIVE ? 1 : 0);
+  }
+  return 0;
+}
diff -Nur sdk/tlibc/string/memset_s.c sdk/tlibc/string/memset_s.c
--- sdk/tlibc/string/memset_s.c
+++ sdk/tlibc/string/memset_s.c
@@ -37,6 +37,7 @@
 #include <errno.h>
 #include <stdint.h>
 #include <string.h>
+#include "rts_config.h"
 
 /*
  * __memset_vp is a volatile pointer to a function.
diff -Nur sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp
--- sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp
+++ sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp
@@ -35,6 +35,7 @@
 #include "se_tcrypto_common.h"
 #include "openssl/cmac.h"
 #include "openssl/err.h"
+#include "openssl/evp.h"
 
 /* Message Authentication - Rijndael 128 CMAC
 * Parameters:
diff -Nur sdk/trts/init_enclave.cpp sdk/trts/init_enclave.cpp
--- sdk/trts/init_enclave.cpp
+++ sdk/trts/init_enclave.cpp
@@ -47,6 +47,7 @@
 #include "trts_internal.h"
 #include "linux/elf_parser.h"
 #include "rts.h"
+#include "rts_config.h"
 #include "trts_util.h"
 #include "se_memcpy.h"
 
@@ -55,7 +56,7 @@
 int EDMM_supported __attribute__((section(RELRO_SECTION_NAME))) = 0;
 sdk_version_t g_sdk_version __attribute__((section(RELRO_SECTION_NAME))) = SDK_VERSION_1_5;
 
-const volatile global_data_t g_global_data __attribute__((section(".niprod"))) = {1, 2, 3, 4,
+const volatile global_data_t g_global_data __attribute__((section(".niprod"))) = {1, 2, 3, 4, 5, 6, 7, 8,
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, 0, 0}, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0, 0, {{{0, 0, 0, 0, 0, 0, 0}}}};
 uint32_t g_enclave_state __attribute__((section(".nipd"))) = ENCLAVE_INIT_NOT_STARTED;
 
@@ -197,7 +198,7 @@
     else
 #endif
     {
-        memset_s(GET_PTR(void, enclave_base, g_global_data.heap_offset), g_global_data.heap_size, 0, g_global_data.heap_size);
+        // memset_s(GET_PTR(void, enclave_base, g_global_data.heap_offset), g_global_data.heap_size, 0, g_global_data.heap_size);
     }
 
     g_enclave_state = ENCLAVE_INIT_DONE;
diff -Nur sdk/trts/linux/trts_pic.S sdk/trts/linux/trts_pic.S
--- sdk/trts/linux/trts_pic.S
+++ sdk/trts/linux/trts_pic.S
@@ -40,6 +40,9 @@
 
 #include "trts_pic.h"
 
+    /* .reserved */
+    .section .reserved, "aw",@progbits
+
     /* .text */
     .section .nipx,"ax",@progbits
 
diff -Nur sdk/trts/linux/x86_64/setcontext.S sdk/trts/linux/x86_64/setcontext.S
--- sdk/trts/linux/x86_64/setcontext.S
+++ sdk/trts/linux/x86_64/setcontext.S
@@ -24,12 +24,17 @@
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
 
+#define __NR_rt_sigprocmask 0
+#ifndef __linux__
+#define __linux__
+#endif
+
 #include "ucontext_i.h"
 #if (!ISE)
 #if defined __linux__
-#include <asm/unistd.h>
+//#include <asm/unistd.h>
 #define	SIG_SETMASK   2
-#define	SIGSET_BYTE_SIZE   (64/8)
+#define	SIGSET_BYTE_SIZE   8
 #elif defined __FreeBSD__
 #include <sys/syscall.h>
 #endif
diff -Nur sdk/trts/trts.cpp sdk/trts/trts.cpp
--- sdk/trts/trts.cpp
+++ sdk/trts/trts.cpp
@@ -39,6 +39,8 @@
 #include "global_data.h"
 #include "trts_internal.h"
 #include "internal/rts.h"
+#include "rts_config.h"
+#include "trts_util.h"
 
 #ifdef SE_SIM
 #include "t_instructions.h"    /* for `g_global_data_sim' */
@@ -318,3 +320,7 @@
     return 0;
 }
 
+void sgx_memory_layout(struct SgxMemoryLayout *memory_layout)
+{
+    get_memory_layout(memory_layout);
+}
diff -Nur sdk/trts/trts_ecall.cpp sdk/trts/trts_ecall.cpp
--- sdk/trts/trts_ecall.cpp
+++ sdk/trts/trts_ecall.cpp
@@ -66,6 +66,11 @@
             return SGX_ERROR_ECALL_NOT_ALLOWED;
         return SGX_SUCCESS;
     }
+    // Exception handlers should be allowed no matter what ocall status it is.
+    if (g_ecall_table.ecall_table[ordinal].is_exception)
+    {
+      return SGX_SUCCESS;
+    }
     ocall_context_t *context = reinterpret_cast<ocall_context_t*>(thread_data->last_sp);
     if(context->ocall_flag != OCALL_FLAG)
     {
@@ -339,7 +344,7 @@
     return SGX_SUCCESS;
 }
 
-sgx_status_t do_ecall(int index, void *ms, void *tcs)
+sgx_status_t do_ecall(int index, void *ms, void *tcs, bool interrupted)
 {
     sgx_status_t status = SGX_ERROR_UNEXPECTED;
     if(ENCLAVE_INIT_DONE != get_enclave_state())
@@ -347,7 +352,9 @@
         return status;
     }
     thread_data_t *thread_data = get_thread_data();
-    if( (NULL == thread_data) || ((thread_data->stack_base_addr == thread_data->last_sp) && (0 != g_global_data.thread_policy)))
+    // The thread local storage should not be cleared if this is a signal
+    // handling ecall that interrupts the original ecall.
+    if(!interrupted && ((NULL == thread_data) || ((thread_data->stack_base_addr == thread_data->last_sp) && (0 != g_global_data.thread_policy))))
     {
         status = do_init_thread(tcs, false);
         if(0 != status)
diff -Nur sdk/trts/trts_internal.h sdk/trts/trts_internal.h
--- sdk/trts/trts_internal.h
+++ sdk/trts/trts_internal.h
@@ -40,6 +40,8 @@
 typedef struct {
     const void     *ecall_addr;
     uint8_t         is_priv;
+    uint8_t         is_exception;
+    uint8_t         is_utility;
 } ecall_addr_t;
 
 typedef struct {
@@ -66,7 +68,10 @@
 
 sgx_status_t do_init_thread(void *tcs, bool enclave_init);
 sgx_status_t do_init_enclave(void *ms, void *tcs) __attribute__((section(".nipx")));
-sgx_status_t do_ecall(int index, void *ms, void *tcs);
+// If |interrupted| is true, this is a user defined exception handler ecall
+// which interrupts the current running ecall, while trts_handle_exception deals
+// with the sgx defined exceptions.
+sgx_status_t do_ecall(int index, void *ms, void *tcs, bool interrupted);
 sgx_status_t do_oret(void *ms);
 sgx_status_t trts_handle_exception(void *tcs);
 sgx_status_t do_ecall_add_thread(void *ms);
diff -Nur sdk/trts/trts_nsp.cpp sdk/trts/trts_nsp.cpp
--- sdk/trts/trts_nsp.cpp
+++ sdk/trts/trts_nsp.cpp
@@ -48,7 +48,8 @@
 #include "trts_internal.h"
 #include "internal/rts.h"
 
-static void init_stack_guard(void *tcs)
+static void __attribute__((optimize("no-stack-protector")))
+init_stack_guard(void *tcs)
 {
     thread_data_t *thread_data = get_thread_data();
     if( (NULL == thread_data) || ((thread_data->stack_base_addr == thread_data->last_sp) && (0 != g_global_data.thread_policy)))
@@ -87,13 +88,24 @@
         return error;
     }
 
-    if(cssa == 0)
-    {
+    // Check whether the incoming ecall is a user exception. If index is within
+    // range of the ecall table size, the is_exception field will be true for
+    // user exceptions.
+    uint8_t is_user_exception =
+        (index >= 0 && index < int(g_ecall_table.nr_ecall)) &&
+        g_ecall_table.ecall_table[index].is_exception;
+    // For a user exception, call |do_ecall| to enter enclave and handle the
+    // signal, in this case cssa could be 0 or 1 (which is likely to be 1 when
+    // an enclave is interrupted by an exception).
+    if(cssa == 0 || (is_user_exception && cssa == 1))    {
         if((index >= 0) || (index == ECMD_INIT_SWITCHLESS) || (index == ECMD_RUN_SWITCHLESS_TWORKER))
         {
             // Initialize stack guard if necessary
             init_stack_guard(tcs);
-            error = do_ecall(index, ms, tcs);
+            // If |cssa| is non-zero, this ecall is entering enclave as a user
+            // exception that interrupts the current running ecall.
+            bool is_interrupted = cssa != 0;
+            error = do_ecall(index, ms, tcs, is_interrupted);
         }
         else if(index == ECMD_INIT_ENCLAVE)
         {
diff -Nur sdk/trts/trts_shared_constants.h sdk/trts/trts_shared_constants.h
--- sdk/trts/trts_shared_constants.h
+++ sdk/trts/trts_shared_constants.h
@@ -47,7 +47,7 @@
 #endif
 
 
-#define STATIC_STACK_SIZE   688
+#define STATIC_STACK_SIZE   (8 * 1024)
 
 
 #endif
diff -Nur sdk/trts/trts_util.cpp sdk/trts/trts_util.cpp
--- sdk/trts/trts_util.cpp
+++ sdk/trts/trts_util.cpp
@@ -30,6 +30,7 @@
  */
 
 
+#include "trts_internal.h"
 #include "trts_util.h"
 #include "global_data.h"
 #include "util.h"
@@ -72,6 +73,31 @@
     return heap_size;
 }
 
+// A 1M bytes temporary storage buffer.
+static char reserved[1024 * 1024] __attribute__((section(".reserved")));
+
+void get_memory_layout(struct SgxMemoryLayout *memory_layout)
+{
+    // Enclave initialized data/uninitialized data/heap.
+    memory_layout->data_base = GET_PTR(void, &__ImageBase, g_global_data.data_offset);
+    memory_layout->data_size = static_cast<size_t>(g_global_data.data_size);
+    memory_layout->bss_base = GET_PTR(void, &__ImageBase, g_global_data.bss_offset);
+    memory_layout->bss_size = static_cast<size_t>(g_global_data.bss_size);
+    memory_layout->heap_base = get_heap_base();
+    memory_layout->heap_size = get_heap_size();
+
+    // Current tcs thread data/stack.
+    thread_data_t *thread_data = get_thread_data();
+    memory_layout->thread_base = reinterpret_cast<void *>(thread_data);
+    memory_layout->thread_size = sizeof(thread_data_t);
+    memory_layout->stack_base = reinterpret_cast<void *>(thread_data->stack_base_addr + static_cast<size_t>(STATIC_STACK_SIZE));
+    memory_layout->stack_limit = reinterpret_cast<void *>(thread_data->stack_limit_addr);
+
+    // Temporary storage buffer section.
+    memory_layout->reserved_base = reinterpret_cast<void *>(reserved);
+    memory_layout->reserved_size = sizeof(reserved);
+}
+
 int * get_errno_addr(void)
 {
     thread_data_t *thread_data = get_thread_data();
diff -Nur sdk/trts/trts_util.h sdk/trts/trts_util.h
--- sdk/trts/trts_util.h
+++ sdk/trts/trts_util.h
@@ -36,6 +36,7 @@
 #include <stddef.h>    /* for size_t */
 #include <stdbool.h>
 #include "se_types.h"
+#include "sgx_trts.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -44,6 +45,7 @@
 void * get_heap_base(void);
 size_t get_heap_size(void);
 size_t get_heap_min_size(void);
+void get_memory_layout(struct SgxMemoryLayout *memory_layout);
 int * get_errno_addr(void);
 bool is_stack_addr(void *address, size_t size);
 bool is_valid_sp(uintptr_t sp);
--- /dev/null
+++ BUILD
@@ -0,0 +1,1177 @@
+# linux-sgx is the Intel SGX SDK
+
+# "notice" licenses present:
+# BSD (Intel SGX SDK, libunwind, libcxxrt),
+# NetBSD, FreeBSD, OpenBSD
+# zlib/libpng (Tinyxml)
+# UIUC (LLVM's compiler_rt library)
+# Apache v2 (EPID SDK)
+# STLPort
+# OpenSSL/SSLeay* (OpenSSL),
+
+# "reciprocal" licenses mentioned but unused:
+# Eclipse public license 1.0 (SGX Eclipse plugin)
+
+# "restricted" licenses present:
+# GPLv2 (ittnotify)
+
+# "restricted" licenses mentioned but unused:
+# Intel (precompiled signed enclaves),
+# Intel sample code license (rdrand)
+
+# "unencumbered" licenses present:
+# SQLite
+# CC0 1.0 (DLMalloc),
+licenses(["reciprocal"])  # Eclipse public license
+
+exports_files([
+    "LICENSE",
+    "enclave_sim.lds",
+    "enclave_test_private.pem",
+])
+
+load(
+    ":sgx_sdk.bzl",
+    "sgx_enclave",
+    "sgx_enclave_configuration",
+)
+
+config_setting(
+    name = "dbg",
+    values = {
+        "compilation_mode": "dbg",
+    },
+    visibility = ["//visibility:public"],
+)
+
+sgx_enclave_configuration(
+    name = "enclave_debug_config",
+    visibility = ["//visibility:public"],
+)
+
+
+proto_library(
+    name = "ipc_common_proto",
+    srcs = ["psw/ae/common/proto/messages.proto"],
+)
+cc_proto_library(
+    name = "ipc_common_proto_cc",
+    deps = [":ipc_common_proto"],
+)
+
+SL_COMMON_SRCS = [
+    "common/src/sl_fcall_mngr_common.c",
+    "common/src/sl_siglines_common.c",
+]
+
+RTS_COMMON_SRCS = [
+    "common/src/linux/xsave_gnu.S",
+]
+
+SL_COMMON_HDRS = [
+    # Headers for switchless calls that must be copied to reinterpret with or
+    # without -DSL_INSIDE_ENCLAVE.
+    "common/inc/internal/sl_uswitchless.h",
+    "common/inc/internal/sl_workers.h",
+    "common/inc/internal/sl_fcall_mngr.h",
+    "common/inc/internal/sl_fcall_mngr_common.h",  # depends of sl_fcall_mngr.h
+    "common/inc/internal/sl_debug.h",
+    "common/inc/internal/sl_siglines.h",
+]
+
+RTS_COMMON_TEXTUAL_HDRS = [
+    "common/inc/internal/linux/linux-regs.h",  # included as ASM
+]
+
+URTS_COMMON_SRCS = RTS_COMMON_SRCS + [
+    "common/src/sgx_memset_s.cpp",
+    "psw/urts/cpu_features.cpp",
+    "psw/urts/enclave.cpp",
+    "psw/urts/enclave_mutex.cpp",
+    "psw/urts/launch_checker.cpp",
+    "psw/urts/linux/debugger_support.cpp",
+    "psw/urts/linux/enter_enclave.S",
+    "psw/urts/linux/get_thread_id.cpp",
+    "psw/urts/linux/misc.cpp",
+    "psw/urts/linux/sig_handler.cpp",
+    "psw/urts/linux/urts.cpp",
+    "psw/urts/linux/urts_emodpr.cpp",
+    "psw/urts/linux/urts_internal.cpp",
+    "psw/urts/linux/urts_trim.cpp",
+    "psw/urts/loader.cpp",
+    "psw/urts/node.cpp",
+    "psw/urts/parser/elf32parser.cpp",
+    "psw/urts/parser/elf64parser.cpp",
+    "psw/urts/parser/parserfactory.cpp",
+    "psw/urts/parser/section.cpp",
+    "psw/urts/prd_css_util.cpp",
+    "psw/urts/routine.cpp",
+    "psw/urts/se_detect.cpp",
+    "psw/urts/se_ocalls.cpp",
+    "psw/urts/tcs.cpp",
+    "psw/urts/urts_version.cpp",
+    "psw/urts/urts_xsave.cpp",
+]
+
+URTS_COMMON_HDRS = [
+    "common/inc/internal/enclave_creator.h",
+    "psw/urts/cpu_features.h",
+    "psw/urts/create_param.h",
+    "psw/urts/enclave.h",
+    "psw/urts/enclave_creator_hw.h",
+    "psw/urts/file.h",
+    "psw/urts/launch_checker.h",
+    "psw/urts/linux/debugger_support.h",
+    "psw/urts/linux/read_xcr0.h",
+    "psw/urts/linux/sig_handler.h",
+    "psw/urts/linux/urts_emodpr.h",
+    "psw/urts/linux/urts_trim.h",
+    "psw/urts/loader.h",
+    "psw/urts/node.h",
+    "psw/urts/parser/binparser.h",
+    "psw/urts/parser/elf32parser.h",
+    "psw/urts/parser/elf64parser.h",
+    "psw/urts/parser/parserfactory.h",
+    "psw/urts/parser/section.h",
+    "psw/urts/prd_css_util.h",
+    "psw/urts/se_detect.h",
+    "psw/urts/section_info.h",
+    "psw/urts/tcs.h",
+]
+
+URTS_COMMON_TEXTUAL_HDRS = RTS_COMMON_TEXTUAL_HDRS + [
+    "psw/urts/parser/clearvars.h",
+    "psw/urts/linux/enter_enclave.h",
+    "psw/urts/parser/elfparser.h",
+    "psw/urts/parser/elfparser.cpp",
+    "psw/urts/parser/update_global_data.hxx",
+    "psw/urts/urts_com.h",
+]
+
+PSW_COMMON_SRCS = glob(["psw/ae/common/src/*.cpp"]) + [
+    "psw/enclave_common/sgx_enclave_common.cpp",
+    "psw/uae_service/uae_wrapper/src/AEServicesImpl.cpp",
+    "psw/uae_service/uae_wrapper/src/AEServicesProvider.cpp",
+    "psw/uae_service/uae_wrapper/src/tae_ocall_api.cpp",
+    "psw/uae_service/uae_wrapper/src/uae_api.cpp",
+    "psw/uae_service/uae_service_assert.cpp",
+    "psw/uae_service/uae_service_version.cpp",
+    "psw/urts/linux/edmm_utility.cpp",
+]
+
+PSW_COMMON_HDRS = glob(["psw/ae/common/inc/*.h"]) + [
+    "psw/enclave_common/sgx_enclave_common.h",
+    "common/inc/sgx_uae_service.h",
+    "psw/uae_service/uae_wrapper/inc/AEServices.h",
+    "psw/uae_service/config.h",
+    "psw/uae_service/uae_wrapper/inc/AEServicesImpl.h",
+    "psw/uae_service/uae_wrapper/inc/AEServicesProvider.h",
+    "psw/ae/aesm_service/source/upse/platform_info_blob.h",
+    "psw/ae/inc/aeerror.h",
+    "psw/ae/inc/byte_order.h",
+    "psw/ae/inc/se_sig_rl.h",
+    "psw/urts/linux/edmm_utility.h",
+    "psw/urts/linux/isgx_user.h",
+]
+
+PSW_COMMON_INCLUDES = [
+    "-Iexternal/linux_sgx/psw/ae/common/inc",
+    "-Iexternal/linux_sgx/psw/ae/common/proto",
+    "-Iexternal/linux_sgx/psw/uae_service/uae_wrapper/inc",
+    "-Iexternal/linux_sgx/psw/ae/inc",
+    "-Iexternal/linux_sgx/psw/ae/inc/internal",
+    "-Iexternal/linux_sgx/psw/ae/aesm_service/source",
+]
+
+cc_library(
+    name = "se_wrapper",
+    srcs = [
+        "common/src/se_event.c",
+        "common/src/se_map.c",
+        "common/src/se_memory.c",
+        "common/src/se_rwlock.c",
+        "common/src/se_thread.c",
+        "common/src/se_time.c",
+        "common/src/se_trace.c",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    deps = [
+        ":common_inc_internal",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "uae_service_hw",
+    srcs = PSW_COMMON_SRCS + [
+        "psw/uae_service/sgx_uae_service.cpp",
+    ],
+    hdrs = PSW_COMMON_HDRS,
+    copts = PSW_COMMON_INCLUDES + [
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/linux_sgx/external/epid-sdk/ext/ipp/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/sdk/src/ittnotify",
+        "-Iexternal/linux_sgx/psw/ae/common",
+        "-Iexternal/linux_sgx/psw/enclave_common",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/boringssl",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+        "-Wl,--export-dynamic",
+        "-lrt",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":epid_inc",
+        ":ipc_common_proto_cc",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "urts_hw",
+    srcs = URTS_COMMON_SRCS + [
+        "psw/urts/enclave_creator_hw_com.cpp",
+        "psw/urts/linux/enclave_creator_hw.cpp",
+    ],
+    hdrs = URTS_COMMON_HDRS,
+    copts = PSW_COMMON_INCLUDES + [
+        "-DElfParser=Elf64Parser",
+        "-Iexternal/linux_sgx/external/vtune/linux/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/sdk/src/ittnotify",
+        "-Iexternal/linux_sgx/psw/enclave_common",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/boringssl",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+    ],
+    textual_hdrs = URTS_COMMON_TEXTUAL_HDRS + [
+        "common/inc/internal/se_lock.hpp",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":epid_inc",
+        ":ipc_common_proto_cc",
+        ":ittnotify_lib",
+        ":psw_switchless",
+        ":rts_common",
+        ":se_wrapper",
+        ":uae_service_hw",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "ittnotify_lib",
+    srcs = [
+        "external/vtune/linux/include/legacy/ittnotify.h",
+        "external/vtune/linux/sdk/src/ittnotify/disable_warnings.h",
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_static.c",
+    ],
+    hdrs = [
+        "external/vtune/linux/include/ittnotify.h",
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_config.h",
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_types.h",
+    ],
+    copts = [
+        "-DITT_ARCH_IA64",
+        "-Iexternal/linux_sgx/external/vtune/linux/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/sdk/src/ittnotify",
+    ],
+    textual_hdrs = [
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_static.h",
+    ],
+)
+
+cc_binary(
+    name = "sgx_sign_tool",
+    srcs = [
+        "external/tinyxml2/tinyxml2.cpp",
+        "external/tinyxml2/tinyxml2.h",
+        "sdk/sign_tool/SignTool/elf_helper.h",
+        "sdk/sign_tool/SignTool/enclave_creator_sign.cpp",
+        "sdk/sign_tool/SignTool/enclave_creator_sign.h",
+        "sdk/sign_tool/SignTool/manage_metadata.cpp",
+        "sdk/sign_tool/SignTool/manage_metadata.h",
+        "sdk/sign_tool/SignTool/parse_key_file.cpp",
+        "sdk/sign_tool/SignTool/parse_key_file.h",
+        "sdk/sign_tool/SignTool/sign_tool.cpp",
+        "sdk/sign_tool/SignTool/util_st.cpp",
+        "sdk/sign_tool/SignTool/util_st.h",
+    ],
+    copts = [
+        "-Wno-sign-compare",
+        "-fpie",
+        "-Iexternal/linux_sgx/external/tinyxml2",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/sdk/sign_tool/SignTool",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/boringssl",
+        "-DSE_DEBUG_LEVEL=SE_TRACE_DEBUG",
+    ],
+    visibility = ["//visibility:public"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":untrusted_inc_internal",
+        ":urts_select",
+        "@boringssl//:crypto",
+    ],
+)
+
+TRTS_COMMON_SRCS = RTS_COMMON_SRCS + [
+    "sdk/trts/init_enclave.cpp",
+    "sdk/trts/init_optimized_lib.cpp",
+    "sdk/trts/linux/elf_parser.c",
+    "sdk/trts/linux/global_init.c",
+    "sdk/trts/linux/metadata_sec.S",
+    "sdk/trts/linux/tls_support.c",
+    "sdk/trts/linux/trts_pic.S",
+    "sdk/trts/linux/x86_64/setcontext.S",
+    "sdk/trts/trts.cpp",
+    "sdk/trts/trts_add_trim.cpp",
+    "sdk/trts/trts_ecall.cpp",
+    "sdk/trts/trts_emodpr.cpp",
+    "sdk/trts/trts_nsp.cpp",
+    "sdk/trts/trts_ocall.cpp",
+    "sdk/trts/trts_switchless.cpp",
+    "sdk/trts/trts_trim.cpp",
+    "sdk/trts/trts_util.cpp",
+    "sdk/trts/trts_veh.cpp",
+    "sdk/trts/trts_version.cpp",
+    "sdk/trts/trts_xsave.cpp",
+]
+
+TRTS_COMMON_HDRS = [
+    "sdk/cpprt/linux/libunwind/src/x86_64/ucontext_i.h",
+    "sdk/trts/init_optimized_lib.h",
+    "sdk/trts/linux/elf_parser.h",
+    "sdk/trts/trts_emodpr.h",
+    "sdk/trts/trts_trim.h",
+    "sdk/trts/trts_util.h",
+]
+
+TRTS_COMMON_TEXTUAL_HDRS = RTS_COMMON_TEXTUAL_HDRS + ["sdk/trts/linux/trts_pic.h"]
+
+cc_library(
+    name = "trts_common",
+    hdrs = [
+        "sdk/trts/trts_internal.h",
+        "sdk/trts/trts_shared_constants.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts",
+    ],
+    features = ["pic"],
+    deps = [
+        ":common_inc_internal",
+        ":trts_switchless",
+    ],
+)
+
+cc_library(
+    name = "trts_hw",
+    srcs = TRTS_COMMON_SRCS + TRTS_COMMON_HDRS,
+    copts = [
+        "-DISE=1",
+        "-DSL_INSIDE_ENCLAVE",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts",
+        "-Iexternal/linux_sgx/sdk/cpprt/linux/libunwind/src/x86_64",
+    ],
+    features = ["pic"],
+    linkopts = [
+        "-Wl,--no-as-needed",
+    ],
+    linkstatic = 1,
+    textual_hdrs = TRTS_COMMON_TEXTUAL_HDRS,
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":rts_common",
+        ":trts_common",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "trts_switchless",
+    srcs = SL_COMMON_SRCS + SL_COMMON_HDRS + [
+        "sdk/switchless/src/sgx_ocall_switchless.c",
+        "sdk/switchless/src/sl_fcall_mngr.c",
+        "sdk/switchless/src/sl_init.c",
+        "sdk/switchless/src/sl_memlog.c",
+        "sdk/switchless/src/sl_once.c",
+        "sdk/switchless/src/sl_printk.c",
+        "sdk/switchless/src/sl_siglines.c",
+        "sdk/switchless/src/sl_workers.c",
+    ],
+    copts = [
+        "-std=c11",
+        "-DSL_INSIDE_ENCLAVE",
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    features = ["pic"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":sgx_runtime_support",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "trts_sim",
+    srcs = TRTS_COMMON_SRCS + TRTS_COMMON_HDRS + [
+        "sdk/selib/sgx_create_report.cpp",
+        "sdk/selib/sgx_get_key.cpp",
+        "sdk/selib/sgx_verify_report.cpp",
+        "sdk/selib/tservice_version.cpp",
+    ],
+    copts = [
+        "-DSE_SIM=1",
+        "-DISE=1",
+        "-DSL_INSIDE_ENCLAVE",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/cpprt/linux/libunwind/src/x86_64",
+    ],
+    features = ["pic"],
+    linkopts = [
+        "-Wl,--defsym,__ImageBase=0",
+    ],
+    linkstatic = 1,
+    textual_hdrs = TRTS_COMMON_TEXTUAL_HDRS,
+    deps = [
+        ":common_inc_internal",
+        ":tinst_sim",
+        ":trts_common",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+    ],
+    alwayslink = 1,
+)
+
+cc_library(
+    name = "rts_common",
+    srcs = [
+        "common/src/crypto_cmac_128.cpp",
+        "common/src/crypto_evp_digest.cpp",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/boringssl",
+    ],
+    features = ["pic"],
+    deps = [
+        ":common_inc_internal",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "sim_common",
+    srcs = [
+        "sdk/simulation/assembly/linux/lowlib.S",
+        "sdk/simulation/uinst/linux/restore_tls.c",
+    ],
+    hdrs = [
+        "sdk/simulation/assembly/linux/gnu_tls.h",
+        "sdk/simulation/assembly/lowlib.h",
+        "sdk/simulation/tinst/deriv.h",
+        "sdk/simulation/tinst/rts_sim.h",
+        "sdk/simulation/uinst/td_mngr.h",
+    ],
+    copts = [
+        "-DSE_SIM=1",
+        "-Wa,--noexecstack",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly/linux",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed",
+    ],
+    linkstatic = 1,
+    textual_hdrs = RTS_COMMON_TEXTUAL_HDRS,
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":rts_common",
+    ],
+)
+
+cc_library(
+    name = "tinst_sim",
+    srcs = [
+        "sdk/simulation/tinst/deriv.cpp",
+        "sdk/simulation/tinst/t_instructions.cpp",
+    ],
+    hdrs = [
+        "sdk/simulation/tinst/t_instructions.h",
+    ],
+    copts = [
+        "-DSE_SIM=1",
+        "-fno-rtti",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly",
+    ],
+    deps = [
+        ":sim_common",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "uae_service_sim",
+    srcs = PSW_COMMON_SRCS + [
+        "common/src/sgx_read_rand.cpp",
+        "external/rdrand/rdrand.h",
+        "external/rdrand/src/config.h",
+        "external/rdrand/src/rdrand.c",
+        "external/rdrand/src/rdrand.h",
+        "psw/ae/common/se_sig_rl.cpp",
+        "sdk/simulation/uae_service_sim/licensing_sim.cpp",
+        "sdk/simulation/uae_service_sim/linux/platform_service_sim.cpp",
+        "sdk/simulation/uae_service_sim/platform_service_sim_com.cpp",
+        "sdk/simulation/uae_service_sim/quoting_sim.cpp",
+        "sdk/simulation/uae_service_sim/uae_service_sim.h",
+        "sdk/simulation/urtssim/cpusvn_util.h",
+        "sdk/simulation/urtssim/cpusvn_util.cpp",
+    ],
+    hdrs = PSW_COMMON_HDRS,
+    copts = PSW_COMMON_INCLUDES + [
+        "-DSE_SIM=1",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/linux_sgx/external/epid-sdk/ext/ipp/include",
+        "-Iexternal/linux_sgx/external/rdrand",
+        "-Iexternal/linux_sgx/psw/ae/common",
+        "-Iexternal/linux_sgx/psw/enclave_common",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/uae_service_sim",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/urtssim",
+        "-Iexternal/linux_sgx/sdk/tseal",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+        "-Wl,--export-dynamic",
+        "-lrt",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":epid_inc",
+        ":ipc_common_proto_cc",
+        ":sim_common",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        ":untrusted_sim_inc",
+    ],
+)
+
+# Target selecting either simulation mode or hardware mode includes for the UAE
+# service library based on the value of SGX_SIM.
+cc_library(
+    name = "uae_service_select",
+    deps = [":se_wrapper"] + select({
+        ":sgx_hw": [":uae_service_hw"],
+        "//conditions:default": [":uae_service_sim"],
+    }),
+)
+
+# A non-versioned, publicly-consumable target for the UAE service.
+cc_library(
+    name = "uae_service",
+    hdrs = ["include/sgx_uae_service.h"],
+    visibility = ["//visibility:public"],
+    deps = [
+        ":uae_service_select",
+        ":urts_sim",
+    ],
+)
+
+cc_library(
+    name = "untrusted_sim_inc",
+    hdrs = [
+        "psw/ae/inc/internal/pse_types.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "psw_switchless",
+    srcs = SL_COMMON_SRCS + SL_COMMON_HDRS + [
+        "psw/uswitchless/sgx_ecall_switchless_untrusted.c",
+        "psw/uswitchless/sl_fcall_mngr_untrusted.c",
+        "psw/uswitchless/sl_siglines_untrusted.c",
+        "psw/uswitchless/sl_uswitchless_untrusted.c",
+        "psw/uswitchless/sl_workers_untrusted.c",
+    ],
+    copts = ["-Iexternal/linux_sgx/common/inc/internal"],
+    features = ["pic"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "urts_sim",
+    srcs = URTS_COMMON_SRCS + [
+        "sdk/simulation/assembly/linux/sgxsim.S",
+        "sdk/simulation/assembly/sgxsim.h",
+        "sdk/simulation/driver_api/driver_api.cpp",
+        "sdk/simulation/uinst/enclave_mngr.cpp",
+        "sdk/simulation/uinst/enclave_mngr.h",
+        "sdk/simulation/uinst/linux/get_tcs.c",
+        "sdk/simulation/uinst/linux/set_tls.c",
+        "sdk/simulation/uinst/u_instructions.cpp",
+        "sdk/simulation/uinst/u_instructions.h",
+        "sdk/simulation/urtssim/cpusvn_util.cpp",
+        "sdk/simulation/urtssim/cpusvn_util.h",
+        "sdk/simulation/urtssim/enclave_creator_sim.cpp",
+        "sdk/simulation/urtssim/enclave_creator_sim.h",
+        "sdk/simulation/urtssim/get_state.cpp",
+        "sdk/simulation/urtssim/urts_sim.h",
+    ],
+    hdrs = URTS_COMMON_HDRS + PSW_COMMON_HDRS,
+    copts = PSW_COMMON_INCLUDES + [
+        "-DSE_SIM=1",
+        "-DElfParser=Elf64Parser",
+        "-Wa,--noexecstack",
+        "-Iexternal/linux_sgx/external/vtune/linux/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/sdk/src/ittnotify",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/sdk/simulation/urtssim",
+        "-Iexternal/boringssl",
+    ],
+    features = ["pic"],  # Not trusted, but Intel's Makefile has -fPIC
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+    ],
+    linkstatic = 1,
+    textual_hdrs = URTS_COMMON_TEXTUAL_HDRS + [
+        "sdk/simulation/assembly/linux/sw_emu.h",  # included as ASM
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":epid_inc",
+        ":ipc_common_proto_cc",
+        ":ittnotify_lib",
+        ":psw_switchless",
+        ":se_wrapper",
+        ":sim_common",
+        ":uae_service_sim",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        ":untrusted_sim_inc",
+        "@boringssl//:crypto",
+    ],
+)
+
+# The headers that are common across trusted and untrusted targets.
+cc_library(
+    name = "common_inc",
+    hdrs = [
+        "common/inc/sgx.h",
+        "common/inc/sgx_attributes.h",
+        "common/inc/sgx_cpuid.h",
+        "common/inc/sgx_defs.h",
+        "common/inc/sgx_dh.h",
+        "common/inc/sgx_ecp_types.h",
+        "common/inc/sgx_edger8r.h",
+        "common/inc/sgx_eid.h",
+        "common/inc/sgx_error.h",
+        "common/inc/sgx_key.h",
+        "common/inc/sgx_key_exchange.h",
+        "common/inc/sgx_lfence.h",
+        "common/inc/sgx_quote.h",
+        "common/inc/sgx_report.h",
+        "common/inc/sgx_tae_service.h",
+        "common/inc/sgx_tcrypto.h",
+        "common/inc/sgx_thread.h",
+        "common/inc/sgx_tseal.h",
+        "common/inc/sgx_uswitchless.h",
+    ],
+    includes = [
+        "common/inc",
+    ],
+)
+
+cc_library(
+    name = "untrusted_inc",
+    hdrs = [
+        "common/inc/sgx_urts.h",
+    ],
+    deps = [":common_inc"],
+)
+
+cc_library(
+    name = "common_inc_internal",
+    srcs = [
+        "common/src/sl_memlog_common.c",
+        "common/src/sl_once_common.c",
+    ],
+    hdrs = [
+        "common/inc/internal/arch.h",
+        "common/inc/internal/cpputil.h",
+        "common/inc/internal/cpuid.h",
+        "common/inc/internal/crypto_wrapper.h",
+        "common/inc/internal/elf_util.h",
+        "common/inc/internal/elfheader/elf_common.h",
+        "common/inc/internal/elfheader/elfstructs.h",
+        "common/inc/internal/global_data.h",
+        "common/inc/internal/linux/cpuid_gnu.h",
+        "common/inc/internal/metadata.h",
+        "common/inc/internal/mini_snprintf.h",
+        "common/inc/internal/routine.h",
+        "common/inc/internal/rts.h",
+        "common/inc/internal/rts_cmd.h",
+        "common/inc/internal/se_cdefs.h",
+        "common/inc/internal/se_cpu_feature_defs.h",
+        "common/inc/internal/se_error_internal.h",
+        "common/inc/internal/se_macro.h",
+        "common/inc/internal/se_memcpy.h",
+        "common/inc/internal/se_page_attr.h",
+        "common/inc/internal/se_quote_internal.h",
+        "common/inc/internal/se_stdio.h",
+        "common/inc/internal/se_string.h",
+        "common/inc/internal/se_types.h",
+        "common/inc/internal/se_version.h",
+        "common/inc/internal/sgx_memset_s.h",
+        "common/inc/internal/sl_atomic.h",
+        "common/inc/internal/sl_bitops.h",
+        "common/inc/internal/sl_compiler.h",
+        "common/inc/internal/sl_init.h",
+        "common/inc/internal/sl_memlog.h",
+        "common/inc/internal/sl_once.h",
+        "common/inc/internal/sl_printk.h",
+        "common/inc/internal/sl_spinlock.h",
+        "common/inc/internal/sl_types.h",
+        "common/inc/internal/sl_util.h",
+        "common/inc/internal/thread_data.h",
+        "common/inc/internal/uncopyable.h",
+        "common/inc/internal/uswitchless.h",
+        "common/inc/internal/util.h",
+        "common/inc/internal/xsave.h",
+    ],
+    copts = [
+        # common/inc/internal cannot be included via "includes" since
+        # __cpuid gets overwritten with an incompatible definition from
+        # the usual cpuid.h header file.
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/boringssl",
+    ],
+    textual_hdrs = [
+        "common/inc/internal/inst.h",
+    ],
+    deps = [
+        ":common_inc",
+        ":epid_inc",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "untrusted_inc_internal",
+    hdrs = [
+        "common/inc/internal/driver_api.h",
+        "common/inc/internal/oal/uae_oal_api.h",
+        "common/inc/internal/se_atomic.h",
+        "common/inc/internal/se_debugger_lib.h",
+        "common/inc/internal/se_event.h",
+        "common/inc/internal/se_lock.hpp",
+        "common/inc/internal/se_map.h",
+        "common/inc/internal/se_memory.h",
+        "common/inc/internal/se_rwlock.h",
+        "common/inc/internal/se_string.h",
+        "common/inc/internal/se_thread.h",
+        "common/inc/internal/se_time.h",
+        "common/inc/internal/se_trace.h",
+        "common/inc/internal/se_vendor.h",
+        "common/inc/internal/se_wrapper.h",
+        "common/inc/internal/sgx_read_rand.h",
+        "common/inc/internal/uae_service_internal.h",
+        "psw/ae/inc/internal/aesm_error.h",
+        "psw/ae/inc/internal/epid_pve_type.h",
+    ],
+    copts = [
+        "-DSL_INSIDE_ENCLAVE",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/psw/ae/inc/internal",
+        "-Iexternal/boringssl",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":epid_inc",
+        ":untrusted_inc",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "public",
+    hdrs = [
+        "include/global_data.h",
+        "include/se_memcpy.h",
+        "include/sgx_cpuid.h",
+        "include/sgx_edger8r.h",
+        "include/sgx_eid.h",
+        "include/sgx_error.h",
+        "include/sgx_lfence.h",
+        "include/sgx_quote.h",
+        "include/sgx_report.h",
+        "include/sgx_thread.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    visibility = ["//visibility:public"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "epid_inc",
+    hdrs = [
+        "external/epid-sdk/epid/common/bitsupplier.h",
+        "external/epid-sdk/epid/common/epiddefs.h",
+        "external/epid-sdk/epid/common/errors.h",
+        "external/epid-sdk/epid/common/types.h",
+        "external/epid-sdk/epid/member/api.h",
+    ],
+    includes = [
+        "external/epid-sdk",
+    ],
+)
+
+# Target selecting either simulation or hardware mode untrusted include files
+# based on the value of SGX_SIM.
+cc_library(
+    name = "urts_select",
+    # Reprovide untrusted_inc's header to avoid layering violation.
+    hdrs = URTS_COMMON_HDRS,
+    copts = [
+        "-Wa,--noexecstack",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/linux_sgx/external/epid-sdk/ext/ipp/include",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/sdk/simulation/urtssim",
+        "-Iexternal/linux_sgx/psw/ae/inc/internal",
+        "-Iexternal/linux_sgx/psw/ae/inc",
+        "-Iexternal/boringssl",
+    ],
+    deps = [
+        ":common_inc",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        ":common_inc_internal",
+    ] + select({
+        ":sgx_hw": [
+            ":urts_hw",
+        ],
+        "//conditions:default": [
+            ":urts_sim",
+        ],
+    }),
+)
+
+# A non-versioned publicly-consumable urts.
+cc_library(
+    name = "urts",
+    hdrs = ["include/sgx_urts.h"],
+    visibility = ["//visibility:public"],
+    deps = [
+        ":untrusted_inc",
+        ":urts_select",
+    ],
+)
+
+# The following targets are designed with to be build with the Asylo toolchain.
+cc_library(
+    name = "trusted_inc",
+    srcs = [
+        "sdk/tlibc/gen/se_cpuid.c",
+    ],
+    hdrs = [
+        "common/inc/sgx_trts.h",
+        "common/inc/sgx_trts_exception.h",
+        "common/inc/sgx_utils.h",
+    ],
+    copts = [
+        "-ffreestanding",
+    ],
+    deps = [
+        ":common_inc",
+        ":sgx_runtime_support",
+        ":sgx_spin_lock",
+    ],
+)
+
+cc_library(
+    name = "sgx_runtime_support",
+    srcs = [
+        "runtime_support/sgx_init_crypto_lib.c",
+        "runtime_support/sgx_init_string_lib.c",
+        "sdk/compiler-rt/stack_chk.c",
+        "sdk/tlibc/string/consttime_memequal.c",
+        "sdk/tlibc/string/memset_s.c",
+    ],
+    hdrs = [
+        "runtime_support/rts_config.h",
+    ],
+    includes = ["runtime_support"],
+    visibility = ["//visibility:public"],
+    deps = [":common_inc"],
+)
+
+cc_library(
+    name = "trusted_inc_internal",
+    hdrs = [
+        "common/inc/internal/cpprt_internal.h",
+        "common/inc/internal/dh.h",
+        "common/inc/internal/ecp_interface.h",
+        "common/inc/internal/global_init.h",
+        "common/inc/internal/pcl_common.h",
+        "common/inc/internal/se_cpu_feature.h",
+        "common/inc/internal/se_enclave_type.h",
+        "common/inc/internal/se_tcrypto_common.h",
+        "common/inc/internal/sgx_ecc256_internal.h",
+        "common/inc/internal/sgx_profile.h",
+        "common/inc/internal/sgx_sha256_128.h",
+        "common/inc/internal/ssl_wrapper.h",
+        "common/inc/internal/tae_service_internal.h",
+        "common/inc/internal/trts_inst.h",
+        "common/inc/internal/tseal_migration_attr.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts/",
+        "-Iexternal/boringssl",
+    ],
+    linkopts = ["-Wl,--export-dynamic"],
+    deps = [
+        ":common_inc",
+        ":epid_inc",
+        ":sgx_spin_lock",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "sgx_tthread",
+    srcs = [
+        "sdk/tlibthread/sethread_cond.cpp",
+        "sdk/tlibthread/sethread_internal.h",
+        "sdk/tlibthread/sethread_mutex.cpp",
+        "sdk/tlibthread/sethread_utils.cpp",
+    ],
+    copts = [
+        "-g -O0",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/tlibcrypto",
+        "-Iexternal/linux_sgx/sdk/trts",
+    ],
+    linkstatic = 1,
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":trts_common",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "sgx_tcrypto",
+    srcs = [
+        "sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp",
+        "sdk/tlibcrypto/tcrypto_version.cpp",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/tlibcrypto",
+        "-DUSE_SGXSSL",
+        "-Iexternal/boringssl",
+    ],
+    linkopts = [
+        "-Wl,--export-dynamic",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+        "@boringssl//:crypto",
+    ],
+)
+
+# A wrapping library that wraps linux_sgx targets used by enclave.
+cc_library(
+    name = "intel_runtime",
+    visibility = ["//visibility:public"],
+    deps = [
+        ":common_inc",
+        ":sgx_spin_lock",
+        ":sgx_tcrypto",
+        ":sgx_tthread",
+        ":trts",
+        ":trusted_inc",
+    ],
+)
+
+
+cc_library(
+    name = "sgx_spin_lock",
+    srcs = ["sdk/tlibc/gen/spinlock.c"],
+    hdrs = ["common/inc/sgx_spinlock.h"],
+    copts = [
+        "-ffreestanding",
+    ],
+    deps = [":common_inc"],
+)
+
+
+# Target selecting either simulation or hardware mode trusted include files
+# based on the value of SGX_SIM.
+cc_library(
+    name = "trts",
+    hdrs = [
+        "include/sgx.h",
+        "include/sgx_trts.h",
+        "include/sgx_trts_exception.h",
+    ],
+    visibility = ["//visibility:public"],
+    deps = [
+        ":common_inc",
+        ":trusted_inc",
+    ] + select({
+        ":sgx_hw": [
+            ":trts_hw",
+        ],
+        ":sgx_sim": [
+            ":trts_sim",
+        ],
+        "//conditions:default": [],
+    }),
+)
+
+# The edger8r tool uses an language unsupported by Bazel, so call ocamlbuild
+# in a genrule. (sudo apt-get install ocaml)
+filegroup(
+    name = "edger8r_srcs",
+    srcs = [
+        "sdk/edger8r/linux/Ast.ml",
+        "sdk/edger8r/linux/CodeGen.ml",
+        "sdk/edger8r/linux/Edger8r.ml",
+        "sdk/edger8r/linux/Lexer.mll",
+        "sdk/edger8r/linux/Parser.mly",
+        "sdk/edger8r/linux/Plugin.ml",
+        "sdk/edger8r/linux/Preprocessor.ml",
+        "sdk/edger8r/linux/SimpleStack.ml",
+        "sdk/edger8r/linux/Util.ml",
+    ],
+)
+
+genrule(
+    name = "sgx_edger8r",
+    srcs = [":edger8r_srcs"],
+    outs = ["sgx_edger8r_binary"],
+    cmd = "OUT=`pwd`/$(@); " +
+          "BUILD=`mktemp -d`; " +
+          "LOCS=($(locations :edger8r_srcs)); " +
+          "cd $$(dirname \"$${LOCS[0]}\"); " +
+          # Call ocamlbuild directly instead of make since the default
+          # build directory can get permission denied on mkdir.
+          "ocamlbuild -libs str,unix -build-dir $$BUILD Edger8r.native > /dev/null; " +
+          "cp $$BUILD/Edger8r.native $$OUT",
+    executable = True,
+    output_to_bindir = True,
+    visibility = ["//visibility:public"],
+)
+
+# These configuration settings are used to select build configurations based
+# on if building for hardware or simulation sgx enclaves.
+#   --config=sgx adds --define="SGX_SIM=0"
+#   --config=sgx-sim adds --define="SGX_SIM=1"
+# By default enclave launching applications will support simulation enclaves.
+# You can manually specify "bazel build --define="SGX_SIM=1" :mytarget" to
+# support hardware enclaves.
+config_setting(
+    name = "sgx_hw",
+    values = {
+        "define": "SGX_SIM=0",
+    },
+    visibility = ["//visibility:public"],
+)
+
+config_setting(
+    name = "sgx_sim",
+    values = {
+        "define": "SGX_SIM=1",
+    },
+    visibility = ["//visibility:public"],
+)
--- /dev/null
+++ sgx_sdk.bzl
@@ -0,0 +1,249 @@
+"""Build tools for supporting Intel's SDK."""
+
+load("@com_google_asylo_backend_provider//:enclave_info.bzl", "EnclaveInfo")
+
+SGXEnclaveInfo = provider()
+SGXEnclaveConfigInfo = provider()
+
+
+def _sgx_unsigned_enclave(
+        name,
+        **kwargs):
+    """Build rule for creating an unsigned SGX enclave shared object file.
+
+    Args:
+      name: The enclave target name.
+      **kwargs: cc_binary arguments.
+    """
+
+    # Append enclave specific arguments.
+    kwargs["copts"] = kwargs.get("copts", []) + [
+        "-Iexternal/linux_sgx/common/inc/",
+        "-fstack-protector",
+    ]
+
+    lds_label = "@linux_sgx//:enclave_sim.lds"
+    kwargs["features"] = kwargs.get("features", []) + [
+        "fully_static_link",
+    ]
+    kwargs["linkopts"] = kwargs.get("linkopts", []) + [
+        "-Wl,-Bstatic",
+        "-Wl,-Bsymbolic",
+        "-Wl,-pie,-eenclave_entry",
+        "-Wl,--defsym,__ImageBase=0",
+        "-Wl,--export-dynamic",
+        "-Wl,--version-script",
+        "$(location %s)" % lds_label,
+    ]
+    kwargs["linkshared"] = 1
+    kwargs["linkstatic"] = 1
+    kwargs["deps"] = kwargs.get("deps", []) + [
+        lds_label,
+        "@linux_sgx//:intel_runtime",
+    ]
+
+    # Create rule to build unsigned enclave.
+    native.cc_binary(
+        name = name,
+        visibility = None,
+        **kwargs
+    )
+
+def _sgx_enclave_configuration(ctx):
+    """Implementation of enclave signing configuration file formatting."""
+    xml_file = ctx.actions.declare_file(ctx.label.name + ".xml")
+    ctx.file_action(
+        output = xml_file,
+        content = "\n".join([
+            "<EnclaveConfiguration>",
+            "  <ProdID>%s</ProdID>" % ctx.attr.prodid,
+            "  <ISVSVN>%s</ISVSVN>" % ctx.attr.isvsvn,
+            "  <StackMaxSize>%s</StackMaxSize>" % ctx.attr.stack_max_size,
+            "  <HeapMaxSize>%s</HeapMaxSize>" % ctx.attr.heap_max_size,
+            "  <TCSNum>%s</TCSNum>" % ctx.attr.tcs_num,
+            "  <TCSPolicy>%s</TCSPolicy>" % ctx.attr.tcs_policy,
+            "  <DisableDebug>%s</DisableDebug>" % ctx.attr.disable_debug,
+            "  <ProvisionKey>%s</ProvisionKey>" % ctx.attr.provision_key,
+            "  <MiscSelect>%s</MiscSelect>" % ctx.attr.misc_select,
+            "  <MiscMask>%s</MiscMask>" % ctx.attr.misc_mask,
+            "</EnclaveConfiguration>\n\n",
+        ]),
+    )
+    return [DefaultInfo(files = depset([xml_file])), SGXEnclaveConfigInfo()]
+
+sgx_enclave_configuration = rule(
+    implementation = _sgx_enclave_configuration,
+    output_to_genfiles = True,
+    attrs = {
+        "prodid": attr.string(
+            default = "0",
+            doc = ("The enclave's ISV (Independent Software Vendor) assigned " +
+                   "Product ID"),
+        ),
+        "isvsvn": attr.string(
+            default = "0",
+            doc = ("The enclave's ISV (Independent Software Vendor) assigned " +
+                   "Security Version Number"),
+        ),
+        "stack_max_size": attr.string(
+            default = "0x40000",
+            doc = "The enclave's maximum stack size in bytes (4KB aligned)",
+        ),
+        "heap_max_size": attr.string(
+            default = "0x100000",
+            doc = "The enclave's maximum heap size in bytes (4KB aligned)",
+        ),
+        # 2 tcs are reserved by the framework, 10 are left for users.
+        "tcs_num": attr.string(
+            default = "12",
+            doc = ("The number of Thread Control Structures allocated for " +
+                   "the enclave"),
+        ),
+        "tcs_policy": attr.string(
+            default = "1",
+            doc = ("The TCS management policy (" +
+                   "0 - The TCS is bound to the untrusted thread, " +
+                   "1 - The TCS is unbound to the untrusted thread)"),
+        ),
+        # "1" for release enclaves.
+        "disable_debug": attr.string(
+            default = "0",
+            doc = ("Indicates whether launching the enclave in debug mode is " +
+                   "disabled"),
+        ),
+        "provision_key": attr.string(
+            default = "0",
+            doc = ("Indicates whether the enclave has access to the " +
+                   "Provisioning Key and the Provisioning Seal Key"),
+        ),
+        "misc_select": attr.string(
+            default = "0",
+            doc = "The desired Extended SSA frame feature (must be 0)",
+        ),
+        "misc_mask": attr.string(
+            default = "0xffffffff",
+            doc = "A mask indicating which bits in misc_select are enforced",
+        ),
+    },
+)
+
+def _sgx_debug_sign_enclave_impl(ctx):
+    """Implementation of an automated signing process of an unsigned enclave."""
+    ctx.actions.run_shell(
+        inputs = [
+            ctx.executable._sign_tool,
+            ctx.file.unsigned,
+            ctx.file._key,
+            ctx.file.config,
+        ],
+        outputs = [ctx.outputs.executable],
+        progress_message = "Signing for debug: //{pkg}:{name}".format(
+            pkg = ctx.attr.unsigned.label.package,
+            name = ctx.attr.unsigned.label.name,
+        ),
+        # Suppresses tool output on success.
+        command = "output=`%s $@ 2>&1` || echo $output" %
+                  ctx.executable._sign_tool.path,
+        arguments = [
+            "sign",
+            "-enclave",
+            ctx.file.unsigned.path,
+            "-key",
+            ctx.file._key.path,
+            "-config",
+            ctx.file.config.path,
+            "-out",
+            ctx.outputs.executable.path,
+        ],
+    )
+    return [
+        DefaultInfo(files = depset([ctx.outputs.executable])),
+        EnclaveInfo(),
+        SGXEnclaveInfo(),
+    ]
+
+# Skylark rule for the above implementation. Gives default debug arguments for
+# private attributes for signing tool, signing key, and signing configuration.
+_sgx_debug_sign_enclave = rule(
+    implementation = _sgx_debug_sign_enclave_impl,
+    executable = True,
+    attrs = {
+        "unsigned": attr.label(allow_single_file = True),
+        "config": attr.label(
+            mandatory = True,
+            allow_single_file = True,
+            providers = [SGXEnclaveConfigInfo],
+        ),
+        "_sign_tool": attr.label(
+            default = Label("@linux_sgx//:sgx_sign_tool"),
+            allow_single_file = True,
+            executable = True,
+            cfg = "host",
+        ),
+        "_key": attr.label(
+            default = Label(
+                "@linux_sgx//:enclave_test_private.pem",
+            ),
+            allow_single_file = True,
+        ),
+    },
+)
+
+def sgx_enclave(
+        name,
+        config = "@linux_sgx//:enclave_debug_config",
+        testonly = 0,
+        **kwargs):
+    """Build rule for creating SGX enclave shared object files signed for testing.
+
+    The enclave is signed with test key stored in
+    @linux_sgx//:enclave_test_private.pem.
+
+    This macro creates two build targets:
+      1) name_unsigned.so: cc_binary that builds the unsigned enclave.
+      2) name: internal signing rule that (debug) signs name_unsigned.so.
+
+    Args:
+      name: The debug-signed enclave target name.
+      config: An sgx_enclave_configuration rule.
+      testonly: 0 or 1, set to 1 if the target is only used in tests.
+      **kwargs: cc_binary arguments.
+    Returns:
+      string: The name of the signed enclave.
+    """
+    unsigned_name = _unsigned_enclave_name(name)
+
+    _sgx_unsigned_enclave(
+        name = unsigned_name,
+        testonly = testonly,
+        **kwargs
+    )
+
+    _sgx_debug_sign_enclave(
+        name = name,
+        unsigned = unsigned_name,
+        config = config,
+        testonly = testonly,
+    )
+
+    return name
+
+
+
+def _extend_enclave_name(enclave, str):
+    """Injects 'str' before '.so' if '.so' in enclave, otherwise appends 'str.so'.
+
+    Args:
+      enclave: Input string
+      str: String to append.
+
+    Returns:
+      string: Name of enclave with str appended.
+    """
+    if ".so" not in enclave:
+        return enclave + str + ".so"
+    else:
+        return enclave.replace(".so", str + ".so", 1)
+
+def _unsigned_enclave_name(enclave):
+    return _extend_enclave_name(enclave, "_unsigned")
--- /dev/null
+++ enclave_sim.lds
@@ -0,0 +1,9 @@
+enclave.so
+{
+    global:
+        enclave_entry;
+        g_global_data;
+        g_global_data_sim;
+    local:
+        *;
+};
--- /dev/null
+++ runtime_support/rts_config.h
@@ -0,0 +1,30 @@
+#ifndef _RUNTIME_SUPPORT_RTS_CONFIG_H_
+#define _RUNTIME_SUPPORT_RTS_CONFIG_H_
+
+#include <string.h>
+
+#ifndef _ERNNO_T_DEFINED
+#define _ERRNO_T_DEFINED
+typedef int errno_t;
+#endif
+
+#ifndef HAVE_SET_UCONTEXT
+#define HAVE_SET_UCONTEXT
+ #ifndef __linux__
+ #define __linux__
+ #endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+errno_t memset_s(void *s, size_t smax, int c, size_t n);
+
+int consttime_memequal(const void *b1, const void *b2, size_t len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // _RUNTIME_SUPPORT_RTS_CONFIG_H_
--- /dev/null
+++ runtime_support/sgx_init_string_lib.c
@@ -0,0 +1,8 @@
+
+#include <stdint.h>
+
+int __NR_rt_sigprocmask;
+
+int sgx_init_string_lib(uint64_t cpu_feature_indicator) {
+  return 0;
+}
--- /dev/null
+++ runtime_support/sgx_init_crypto_lib.c
@@ -0,0 +1,10 @@
+
+#include <stdint.h>
+
+#include "sgx_error.h"
+
+sgx_status_t sgx_init_crypto_lib(uint64_t cpu_feature_indicator,
+                                 uint32_t *cpuid_table) {
+  return SGX_SUCCESS;
+}
+
--- /dev/null
+++ include/global_data.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_GLOBAL_DATA_H_
+#define _INCLUDE_GLOBAL_DATA_H_
+
+#include "common/inc/internal/global_data.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_GLOBAL_DATA_H_
--- /dev/null
+++ include/se_memcpy.h
@@ -0,0 +1,6 @@
+#ifndef _V_2_3_INCLUDE_SE_MEMCPY_H_
+#define _V_2_3_INCLUDE_SE_MEMCPY_H_
+
+#include "common/inc/internal/se_memcpy.h"  // IWYU pragma: export
+
+#endif  // _V_2_3_INCLUDE_SE_MEMCPY_H_
--- /dev/null
+++ include/sgx.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_H_
+#define _INCLUDE_SGX_H_
+
+#include "common/inc/sgx.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_H_
--- /dev/null
+++ include/sgx_cpuid.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_INCLUDE_SGX_CPUID_H_
+#define _INCLUDE_INCLUDE_SGX_CPUID_H_
+
+#include "common/inc/sgx_cpuid.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_INCLUDE_SGX_CPUID_H_
--- /dev/null
+++ include/sgx_edger8r.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_EDGER8R_H_
+#define _INCLUDE_SGX_EDGER8R_H_
+
+#include "common/inc/sgx_edger8r.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_EDGER8R_H_
--- /dev/null
+++ include/sgx_eid.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_EID_H_
+#define _INCLUDE_SGX_EID_H_
+
+#include "common/inc/sgx_eid.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_EID_H_
--- /dev/null
+++ include/sgx_error.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_ERROR_H_
+#define _INCLUDE_SGX_ERROR_H_
+
+#include "common/inc/sgx_error.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_ERROR_H_
--- /dev/null
+++ include/sgx_lfence.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_LFENCE_H_
+#define _INCLUDE_SGX_LFENCE_H_
+
+#include "common/inc/sgx_lfence.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_LFENCE_H_
--- /dev/null
+++ include/sgx_quote.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_QUOTE_H_
+#define _INCLUDE_SGX_QUOTE_H_
+
+#include "common/inc/sgx_quote.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_QUOTE_H_
--- /dev/null
+++ include/sgx_report.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_REPORT_H_
+#define _INCLUDE_SGX_REPORT_H_
+
+#include "common/inc/sgx_report.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_REPORT_H_
--- /dev/null
+++ include/sgx_thread.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_THREAD_H_
+#define _INCLUDE_SGX_THREAD_H_
+
+#include "common/inc/sgx_thread.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_THREAD_H_
--- /dev/null
+++ include/sgx_trts.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_TRTS_H_
+#define _INCLUDE_SGX_TRTS_H_
+
+#include "common/inc/sgx_trts.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_TRTS_H_
--- /dev/null
+++ include/sgx_trts_exception.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_TRTS_EXCEPTION_H_
+#define _INCLUDE_SGX_TRTS_EXCEPTION_H_
+
+#include "common/inc/sgx_trts_exception.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_TRTS_EXCEPTION_H_
--- /dev/null
+++ include/sgx_uae_service.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_UAE_SERVICE_H_
+#define _INCLUDE_SGX_UAE_SERVICE_H_
+
+#include "common/inc/sgx_uae_service.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_UAE_SERVICE_H_
--- /dev/null
+++ include/sgx_urts.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_URTS_H_
+#define _INCLUDE_SGX_URTS_H_
+
+#include "common/inc/sgx_urts.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_URTS_H_
